\documentclass[11pt, one side, article]{memoir}


\settrims{0pt}{0pt} % page and stock same size
\settypeblocksize{*}{34.5pc}{*} % {height}{width}{ratio}
\setlrmargins{*}{*}{1} % {spine}{edge}{ratio}
\setulmarginsandblock{.98in}{.98in}{*} % height of typeblock computed
\setheadfoot{\onelineskip}{2\onelineskip} % {headheight}{footskip}
\setheaderspaces{*}{1.5\onelineskip}{*} % {headdrop}{headsep}{ratio}
\checkandfixthelayout


\usepackage{amsthm}
\usepackage{mathtools}

\usepackage[inline]{enumitem}
\usepackage{ifthen}
\usepackage[utf8]{inputenc} %allows non-ascii in bib file
\usepackage{xcolor}

\usepackage[backend=biber, backref=true, maxbibnames = 10, style = alphabetic]{biblatex}
\usepackage[bookmarks=true, colorlinks=true, linkcolor=blue!50!black,
citecolor=orange!50!black, urlcolor=orange!50!black, pdfencoding=unicode]{hyperref}
\usepackage[capitalize]{cleveref}

\usepackage{tikz}

\usepackage{amssymb}
\usepackage{newpxtext}
\usepackage[varg,bigdelims]{newpxmath}
\usepackage{mathrsfs}
\usepackage{dutchcal}
\usepackage{fontawesome}
\usepackage{ebproof}



% cleveref %
  \newcommand{\creflastconjunction}{, and\nobreakspace} % serial comma
  \crefformat{enumi}{\##2#1#3}
  \crefalias{chapter}{section}


% biblatex %
  \addbibresource{Library20211226.bib} 

% hyperref %
  \hypersetup{final}

% enumitem %
  \setlist{nosep}
  \setlistdepth{6}



% tikz %



  \usetikzlibrary{ 
  	cd,
  	math,
  	decorations.markings,
		decorations.pathreplacing,
  	positioning,
  	arrows.meta,
  	shapes,
		shadows,
		shadings,
  	calc,
  	fit,
  	quotes,
  	intersections,
    circuits,
    circuits.ee.IEC
  }
  
  \tikzset{
biml/.tip={Glyph[glyph math command=triangleleft, glyph length=.95ex]},
bimr/.tip={Glyph[glyph math command=triangleright, glyph length=.95ex]},
}

\tikzset{
	tick/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (0,.4ex) -- (0,-.4ex);}}}
  }
} 
\tikzset{
	slash/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (.3ex,.3ex) -- (-.3ex,-.3ex);}}}
  }
} 

\newcommand{\bito}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, biml-bimr, "#1"]\&~\end{tikzcd}  
}
\newcommand{\bifrom}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, bimr-biml, "{#1}"]\&~\end{tikzcd}  
}
\newcommand{\bifromlong}[2][]{
	\begin{tikzcd}[ampersand replacement=\&, column sep=#2, cramped]\ar[r, bimr-biml, "#1"]\&~\end{tikzcd}  
}

% Adjunctions
\newcommand{\adj}[5][30pt]{%[size] Cat L, Left, Right, Cat R.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]
  \ar[r, phantom, "\scriptstyle\Rightarrow"]\&
  #5\ar[l, shift left=7pt, "#4"]
\end{tikzcd}
}

\newcommand{\adjr}[5][30pt]{%[size] Cat R, Right, Left, Cat L.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]\&
  #5\ar[l, shift left=7pt, "#4"]
  \ar[l, phantom, "\scriptstyle\Leftarrow"]
\end{tikzcd}
}

\newcommand{\xtickar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}
\newcommand{\xslashar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}



  
  % amsthm %
\theoremstyle{definition}
\newtheorem{definitionx}{Definition}[chapter]
\newtheorem{examplex}[definitionx]{Example}
\newtheorem{remarkx}[definitionx]{Remark}
\newtheorem{notation}[definitionx]{Notation}


\theoremstyle{plain}

\newtheorem{theorem}[definitionx]{Theorem}
\newtheorem{proposition}[definitionx]{Proposition}
\newtheorem{corollary}[definitionx]{Corollary}
\newtheorem{lemma}[definitionx]{Lemma}
\newtheorem{warning}[definitionx]{Warning}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{proposition*}{Proposition}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{warning*}{Warning}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{construction}[theorem]{Construction}

\newenvironment{example}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\examplex}
  {\popQED\endexamplex}
  
 \newenvironment{remark}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\remarkx}
  {\popQED\endremarkx}
  
  \newenvironment{definition}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\definitionx}
  {\popQED\enddefinitionx} 

    
%-------- Single symbols --------%
	
\DeclareSymbolFont{stmry}{U}{stmry}{m}{n}
\DeclareMathSymbol\fatsemi\mathop{stmry}{"23}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}


%-------- Renewed commands --------%

\renewcommand{\ss}{\subseteq}

%-------- Other Macros --------%


\DeclarePairedDelimiter{\present}{\langle}{\rangle}
\DeclarePairedDelimiter{\copair}{[}{]}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\corners}{\ulcorner}{\urcorner}
\DeclarePairedDelimiter{\ihom}{[}{]}

\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Mor}{Mor}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\idy}{idy}
\DeclareMathOperator{\comp}{com}
\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\ob}{Ob}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\el}{El}




\newcommand{\const}[1]{\texttt{#1}}%a constant, or named element of a set
\newcommand{\Set}[1]{\mathsf{#1}}%a named set
\newcommand{\ord}[1]{\mathsf{#1}}%an ordinal
\newcommand{\cat}[1]{\mathcal{#1}}%a generic category
\newcommand{\Cat}[1]{\mathbf{#1}}%a named category
\newcommand{\fun}[1]{\mathrm{#1}}%a function
\newcommand{\Fun}[1]{\mathit{#1}}%a named functor




\newcommand{\id}{\mathrm{id}}
\newcommand{\then}{\mathbin{\fatsemi}}

\newcommand{\cocolon}{:\!}


\newcommand{\iso}{\cong}
\newcommand{\too}{\longrightarrow}
\newcommand{\tto}{\rightrightarrows}
\newcommand{\To}[2][]{\xrightarrow[#1]{#2}}
\renewcommand{\Mapsto}[1]{\xmapsto{#1}}
\newcommand{\Tto}[3][13pt]{\begin{tikzcd}[sep=#1, cramped, ampersand replacement=\&, text height=1ex, text depth=.3ex]\ar[r, shift left=2pt, "#2"]\ar[r, shift right=2pt, "#3"']\&{}\end{tikzcd}}
\newcommand{\Too}[1]{\xrightarrow{\;\;#1\;\;}}
\newcommand{\from}{\leftarrow}
\newcommand{\ffrom}{\leftleftarrows}
\newcommand{\From}[1]{\xleftarrow{#1}}
\newcommand{\Fromm}[1]{\xleftarrow{\;\;#1\;\;}}
\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\inj}{\rightarrowtail}
\newcommand{\wavyto}{\rightsquigarrow}
\newcommand{\lollipop}{\multimap}
\newcommand{\imp}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\down}{\mathbin{\downarrow}}
\newcommand{\fromto}{\leftrightarrows}
\newcommand{\tickar}{\xtickar{}}
\newcommand{\slashar}{\xslashar{}}



\newcommand{\inv}{^{-1}}
\newcommand{\op}{^\tn{op}}

\newcommand{\tn}[1]{\textnormal{#1}}
\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\wc}[1]{\widecheck{#1}}
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}



\newcommand{\bb}{\mathbb{B}}
\newcommand{\cc}{\mathbb{C}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\pp}{\mathbb{P}}
\newcommand{\qq}{\mathbb{Q}}
\newcommand{\zz}{\mathbb{Z}}
\newcommand{\rr}{\mathbb{R}}


\newcommand{\finset}{\Cat{Fin}}
\newcommand{\smset}{\Cat{Set}}
\newcommand{\smcat}{\Cat{Cat}}
\newcommand{\catsharp}{\Cat{Cat}^{\sharp}}
\newcommand{\ppolyfun}{\mathbb{P}\Cat{olyFun}}
\newcommand{\ccatsharp}{\mathbb{C}\Cat{at}^{\sharp}}
\newcommand{\ccatsharpdisc}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc}}}
\newcommand{\ccatsharplin}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{lin}}}
\newcommand{\ccatsharpdisccon}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc,con}}}
\newcommand{\sspan}{\mathbb{S}\Cat{pan}}
\newcommand{\en}{\Cat{End}}

\newcommand{\List}{\Fun{List}}
\newcommand{\set}{\tn{-}\Cat{Set}}




\newcommand{\yon}{\mathcal{y}}
\newcommand{\poly}{\Cat{Poly}}
\newcommand{\polycart}{\poly^{\Cat{Cart}}}
\newcommand{\ppoly}{\mathbb{P}\Cat{oly}}
\newcommand{\0}{\textsf{0}}
\newcommand{\1}{\tn{\textsf{1}}}
\newcommand{\U}{\tn{\textsf{U}}}
\newcommand{\tri}{\mathbin{\triangleleft}}
\newcommand{\triright}{\mathbin{\triangleright}}
\newcommand{\tripow}[1]{^{\tri #1}}
\newcommand{\indep}{\Fun{Indep}}
\newcommand{\switch}{\pi}


% lenses
\newcommand{\biglens}[2]{
     \begin{bmatrix}{\vphantom{f_f^f}#2} \\ {\vphantom{f_f^f}#1} \end{bmatrix}
}
\newcommand{\littlelens}[2]{
     \begin{bsmallmatrix}{\vphantom{f}#2} \\ {\vphantom{f}#1} \end{bsmallmatrix}
}
\newcommand{\lens}[2]{
  \relax\if@display
     \biglens{#1}{#2}
  \else
     \littlelens{#1}{#2}
  \fi
}



\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\qqand}{\qquad\text{and}\qquad}


\newcommand{\coto}{\nrightarrow}
\newcommand{\cofun}{{\raisebox{2pt}{\resizebox{2.5pt}{2.5pt}{$\setminus$}}}}

\newcommand{\coalg}{\tn{-}\Cat{Coalg}}

\newcommand{\bic}[2]{{}_{#1}\Cat{Comod}_{#2}}

% ---- Changeable document parameters ---- %

\linespread{1.1}
%\allowdisplaybreaks
\setsecnumdepth{section}
\settocdepth{section}
\setlength{\parindent}{15pt}
\setcounter{tocdepth}{1}



%--------------- Document ---------------%
\begin{document}

\title{Polynomial universes:\\Syntax and conversions for dependent types}

\author{David I. Spivak}

\date{\vspace{-.2in}}

\maketitle

\begin{abstract}
\end{abstract}


%-------- Chapter --------%
\chapter{Introduction}



Dependent type theory \cite{martin-lof1975intuitionistic} was founded by Per Martin-L\"{o}f in 1975 to formalize all of mathematics. The basic idea is that \emph{order of events} is fundamental to a mathematical story arc: when playing out any specific example story in that arc, the beginning of the story affects not only the later events, but even the very terms with which the later events will be described. For example, in the story arc of conditional probability, one may say ``now if the set $P$ that we are asked to condition on happens to have measure zero, we must stop; but assuming that's not the case then the result will be a new measure.'' Here the story teller is saying that no terms will describe what happens if $P$ has measure zero, whereas otherwise the terms of standard probability will apply.

Dependent types form a logical system with syntax, conversion rules, and methods of deduction. In \cite{awodey2014natural,awodey2018polynomial}, Awodey and later Newstead show that there is a strong connection between dependent type theory and polynomial functors. The present work follows from this remarkable discovery, but diverges in the formalism itself. Whereas they discuss pseudomonads and pseudo-algebras in a tri-category arising from a locally cartesian closed category, we keep simply to lax monoidal functors and transformations between monoidal categories. In both cases, the focus is on the syntax and conversion rules of dependent type theory, not the universal properties that yield valid deductions.

A polynomial functor $p\colon\smset\to\smset$ is a coproduct of representable functors
\[\sum_{I\in p(1)}\yon^{p[I]},\]
which one can think of as a collection of types: A position $I\in p(1)$ indexing the coproduct is a \emph{type} in the collection, and an element $i\in p[I]$ in the representing set $p[I]$ is a \emph{term} of type $I$. 

Composition $p\tri q$ of polynomials corresponds to dependent types: in order to choose a type $x\in (p\tri q)(1)$ in the composite, you must first choose a type $I\in p(1)$ and then, for any term $i\in p[I]$ of it you choose a type $J:q(1)$. In this paper (not in the literature) we denote this situation by $I\vdash J$. So suppose
\[
  p=\{{'0'}\}\yon^0+\{{'1'}\}\yon^1
  \qqand 
  q=\sum_{N\in\nn}\sum_{\{D\colon N\to\rr_{\geq 0}\mid D_1+\cdots+D_N=1\}}\yon^N.
\]
Then to choose an element $I\vdash J\in (p\tri q)(1)$, you \emph{first} make a binary choice ${'0'}$ or ${'1'}$; that's the type $I$. Then the next type $J$ depends on your choice. Indeed, in the ${'0'}$-case you have already hit the end of the story---you stop---and in the ${'1'}$-case you \emph{further} make choice of $N\in\nn$ and a probability distribution $D$ on a set with $N$ elements. All together, whichever branch you took, the result is a type $I\vdash J$ in the collection $p\tri q$. This type has \emph{no terms} in the ${'0'}$-case, and it has $N$-many terms in the ${'1'}$-case.

A special case of dependent types is \emph{independent} types, where the order of this part of the story \emph{doesn't} matter. These are represented using a symmetric monoidal product $\otimes$ on polynomial functors: for any $p,q$ one can form $p\otimes q$ and there is an isomorphism $p\otimes q\cong q\otimes p$. The types in the family $p\otimes q$ are pairs of types $(I,J)\in p(1)\times q(1)$, and the terms of type $(I,J)$ are pairs of terms $(i,j)\in p[I]\times q[J]$. There is a natural map $\indep\colon(p\otimes q)\to (p\tri q)$ allowing us to regard a pair $(I,J)$ of independent types as a dependent type $(I\vdash J)\coloneqq\indep(I,J)$.

In this paper we explain the notion of a polynomial universe $u$,%
\footnote{Again, this notion is due to \cite[Theorem 16]{awodey2014natural}, where he calls them ``natural model of extensional Martin-L\"{o}f type theory with
product, sum, and identity types''. We focus on what that paper would call the $\mathbb{C}=1$ case, meaning that everything in this paper takes place in $\smset$ rather than an arbitrary presheaf category.}
with which one can reduce all the dependencies by collapsing an arbitrarily deep dependent type into a single layer through products or sums. More generally, we will discuss a map
\begin{equation}\label{eqn.switch}
  \switch_p\colon p\tri u\to u\otimes p
\end{equation}
that converts dependent types into independent types by sending $I\vdash A$ to the pair $(I\to A,A)$, where $I\to A$ might be called the \emph{dependent product type} or \emph{dependent function type}.%
\footnote{This is just a terminological preference: a product $\prod_{a\in A}B$ of $A$-many copies of $B$ is also a function $A\to B$; in both cases the number of $B$'s could depend on the choice of $a\in A$. Allowing ones terminology to depend on ones preferences is a meta-version of this whole story.}
It is as though $u$ is able to absorb the effect of $p$-dependencies into itself, a move which in some sense makes computations into ``first-class objects". When $p=u$ we can convert a dependent type $(A\vdash B)\in u\tri u(1)$ all the way to a base type $(A\to B,A)\in u(1)$ by first absorbing the dependency and then composing with a pairing operation $u\tri u\To{\switch_u} u\otimes u\To{(-,-)} u$.

In this paper we will see that syntax and conversion rules of dependent types  emerge from the very special properties enjoyed by these polynomial universes $u$. Not only should polynomials carry the structure of a cartesian monad, which gives it a unit type $\1$ and $\Sigma$ types, but these must distribute properly over function types. All this is packaged in the following definition.

\begin{definition}[Polynomial universe]\label{def.universe}
Let $(u,\1,\Sigma)$ be a cartesian monad. We say it is a \emph{polynomial universe} if there exists a diagram of the form
\begin{equation}\label{eqn.Phi}
\begin{tikzcd}[column sep=60pt]
	\Big(\polycart,\yon,\tri\Big)
		\ar[r, bend left=15pt,  start anchor={north east}, end anchor={north west}, "\ol{\Phi}_u", ""' name=P]
		\ar[r, bend right=15pt, start anchor={south east}, end anchor={south west}, "\Phi_u"', "" name=PP]&
	\Big(\en(\poly),\id,\circ\Big)
	\ar[from=P, to=P|-PP, Rightarrow, shorten=2mm, "\indep"]
\end{tikzcd}
\end{equation}
where the functors $\ol{\Phi}_u$ and $\Phi_u$ have a lax monoidal structure and are given by
\[
\ol{\Phi}_u(p)(q)\coloneqq u\otimes p\tri q
\qqand
\Phi_u(p)(q)\coloneqq u\tri p\tri q
\]
and the natural transformation also has a monoidal structure and is given by
\[
  u\otimes p\tri q\To{\indep\tri q} u\tri p\tri q.
  \qedhere
\]
\end{definition}

The purpose of the text is to explain all this, so readers should not be concerned if they have lost the connection; our goal now is just to give a sense of the packaging. The crux of the story is that polynomial universes $u$ are things that can coherently absorb arbitrary dependencies into themselves, making computations into first-class types.

In the text below we will give examples of polynomial universes; probably the best known is the list monad
\[
	u_\nn\coloneqq\sum_{N\in\nn}\yon^N
\]
which has a notion of singleton list and a way to concatenate lists of lists into a list.

Let's fix some polynomial universe $(u,\1,\Sigma)$ and write $\Phi$ for $\Phi_u$, etc. The absorption of arbitrary dependencies into $u$ is packaged up into the coherence maps---the \emph{laxators}---of the lax monoidal structure on $\Phi$ and $\ol{\Phi}$. They are of the form
\[
\Phi(p_1)\circ\Phi(p_2)
\Too{\phi_{p_1,p_2}}
\Phi(p_1\tri p_2).
\]
The laxators are formed using the $\switch$-maps described above in \eqref{eqn.switch} and give rise to type- and term-forming operations for dependent function types. The unitality and associativity laws governing $\Phi$ and $\ol{\Phi}$ give rise to the conversion rules between them. For example, from them one can derive a self-distributivity law $u\tri u\to u\tri u$, as discussed in a July 2021 \href{https://topos.site/blog/2021/07/jump-monads-from-conjugation-to-dependent-types/}{Topos Institute blog post}.

As mentioned there, the germination of this idea came from \href{https://www.youtube.com/watch?v=RDuNIP4icKI\&t=10765s}{Steve Awodey's talk} at the 2021 Workshop on Polynomial Functors on his theory of natural models and their connection to polynomial functors. Aside from a very different presentation (lax monoidal functors instead of pseudomonads, etc.), the present work adds two things:
\begin{enumerate}
	\item explicit syntax and rules for pair types, and
	\item the distributive law of $\Pi$ over $\Sigma$, which in the language of \cite{awodey2018polynomial} would say%
	\footnote{In our language it would say 
	\[
	A\to\Sigma(B,C)\cong \Sigma(A\to B,A\to C).
	\]
	}
	\begin{equation}\label{eqn.distributivity_law_we_all_love}
	\prod_{x:A}\sum_{y:B(x)}C(x,y)\cong\sum_{y:\prod_{x:A}B(x)}\prod_{x:A}C(x,y(x))
	\end{equation}
	Awodey-Newstead derived the other law connecting $\Sigma$ and $\Pi$ (see \cite[Remark 4.2]{awodey2018polynomial}), but under our reading they seem to be missing the one in \eqref{eqn.distributivity_law_we_all_love}.%
	\footnote{\href{https://youtu.be/RDuNIP4icKI?t=13898}{Andr\'{e} Joyal's question following Steve Awodey's talk} was ``what happened to the distributivity law that we love between sum and product?" Steve said that he believed it was of the same form as the other laws they had derived, and that they get it for free. I have not seen this derivation, but it may be coming from universal properties. Since neither this nor \cite{awodey2018polynomial} consider universal properties of dependent types, just their formation and rules, we hope that the present paper will be of interest.
	}
\end{enumerate}

%---- Section ----%
\section{Acknowledgments}

I greatly appreciate the clarity of delivery and the insight behind Steve Awodey's talk at the 2021 Workshop on Polynomial Functors. It has been a major source of inspiration and fun during the intervening year.

This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-20-1-0348.

%-------- Chapter --------%
\chapter{Background and key examples}

The main purpose of this section is to fix notation and provide a brief overview of polynomial functors in one variable. But we will also use this section to introduce our main polynomials of interest, which we call $\kappa$-list polynomials.

%---- Section ----%
\section{Basics}

\begin{definition}[Polynomial functor]\label{def.poly}
Given a set $S$, we denote the corresponding representable functor by
\[\yon^S\coloneqq\smset(S,-)\colon\smset\to\smset,\]
e.g. $\yon^S(X)\coloneqq X^S$. In particular $\yon=\yon^1$ is the identity and $\yon^0=1$ is constant singleton.

A \emph{polynomial functor} is a functor $p\colon\smset\to\smset$ that is isomorphic to a sum of representables, i.e.\ for which there exists a set $T$, a set $p[t]\in\smset$ for each $t\in T$, and an isomorphism
\[
p\cong\sum_{t\in T}\yon^{p[t]}.
\]
We call $T$ the set of \emph{$p$-types}, and for each type $t\in T$ we call $p[t]$ the set of \emph{$p$-terms of type $t$}. 

A \emph{morphism} $\varphi\colon p\to p'$ of polynomial functors is simply a natural transformation between them. We denote the category of polynomial functors by $\poly$. It is called \emph{cartesian} if for every map of sets $f\colon S\to S'$, the naturality square
\[
\begin{tikzcd}
  p(S)\ar[r, "p(f)"]\ar[d, "\varphi(S)"']&p(S)\ar[d, "\varphi(S')"]\\
  p'(S')\ar[r, "p'(f)"']&p'(S')\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\]
is a pullback of sets. We denote the wide subcategory of polynomials and cartesian maps by $\polycart$.
\end{definition}

For any polynomial $p=\sum_{t\in T}\yon^{p[t]}$, we have a canonical isomorphism $p(1)\cong T$; hence we will denote $p$ by
\begin{equation}\label{eqn.poly_notation}
p=\sum_{I\in p(1)}\yon^{p[I]}
\end{equation}
so that the $p$-types are written with upper-case letters.

\begin{remark}
Note that there is already some dependency in \cref{def.poly}; in order to define a polynomial we need a set $T$ and then, \emph{for each $t$ in $T$}, we need a representable functor. Thus we can use polynomial functors to explicate the syntax and rules of dependent types, but only if our meta-theory allows us to already know what dependent types are.
\end{remark}

\begin{remark}\label{rem.positions_and_directions}
Using the Yoneda lemma, we can understand a morphism $p\to q$ in $\poly$ to consist of two pieces $(\varphi_1,\varphi^\sharp)$ as follows:
\begin{equation}\label{eqn.mapsharp}
  \varphi_1\colon p(1)\to q(1)
  \qqand
  \varphi^\sharp_I\colon q[J]\to p[I]
\end{equation}
that is, $\varphi_1$ is a function on positions, and $\varphi^\sharp_i$ is a function on directions, \emph{depending on a position $I\in p(1)$}, where $\varphi_1(i)=j$. We refer to $\varphi_1$ as the \emph{on-types function} and to $\varphi^\sharp$ as the \emph{backwards on-terms} function.

One can check that a map $\varphi\colon p\to q$ is cartesian iff the backwards-on-terms function $\varphi^\sharp_I$ is a bijection $p[I]\cong q[\varphi_1I]$ for each type $I\in p(1)$.
\end{remark}



\begin{definition}[Sum-product sets and list polynomials]\label{def.sum_prod_set}
Let $\kappa$ be a set. We say that it is a \emph{sum-product set} if it satisfies the following properties for any sets $A$ and $(B_a)_{a\in A}$ with disjoint union $S(A,B)\coloneqq\coprod_{a\in A}B_a$ and cartesian product $\Pi(A,B)\coloneqq\prod_{a\in A}B_a$:%
\footnote{We write $S(A,B)$ rather than $\Sigma(A,B)$ because we already have used that symbol for a monad structure. Later we will define $\Sigma(A,B)$ to be this $S(A,B)$, so the distinction is not important.}
\begin{enumerate}[label=(\roman*)]
	\item $\kappa$ is nonempty $0<\kappa$;
	\item $\kappa$ is closed under its own sums: if $A<\kappa$ and each $B_a<\kappa$, then $S(A,B)<\kappa$;
	\item $\kappa$ is closed under its own products: if $A<\kappa$ and each $B_a<\kappa$, then $\Pi(A,B)<\kappa$;
	\item there exists a set $C_\kappa$ containing exactly one set of each cardinality $N<\kappa$.%
	\footnote{The set $C_\kappa$ is structure, not property, but any two choices will yield isomorphic list polynomials, so we are not concerned with the distinction here.}
\end{enumerate}

Given a sum-product set $\kappa$, we define the \emph{$\kappa$-list polynomial} to be
\[
  u_\kappa\coloneqq\sum_{N\in C_\kappa}\yon^N
\qedhere
\]
\end{definition}

\begin{example}\label{ex.sum_prod_set}
Given the axiom of choice, any Grothendieck universe is a sum-product set; indeed conditions (i) -- (iii) are satisfied for any Grothendieck universe, and (iv) is satisfied assuming the axiom of choice.

There is only one finite ordinal with the above properties, namely $\kappa=2$. Indeed, $0$ fails condition (i), $1$ fails condition (iii) because $\Pi(0,!)=1\not<1$, and any $2<\kappa<\omega$ fails condition (ii) because by induction $\Pi(\kappa-1,(\kappa-1,\kappa-1))\not<\kappa$.

The easiest intuitive example to keep in mind for our paper is $\kappa=\nn$,%
\footnote{We write $\nn$ rather than $\omega$ for the set of natural numbers, the first infinite ordinal.} so that $N<\nn$ iff $N$ is finite. The $\nn$-list polynomial is
\[
  u_\nn\coloneqq\sum_{N\in\nn}\yon^N.
\qedhere
\]
\end{example}

%---- Section ----%
\section{Composition and Dirichlet monoidal structures}

Polynomial functors are closed under composition, which we denote by $\tri$; its types and terms are given by the following formula:
\begin{equation}\label{eqn.comp_formula}
  \left(\sum_{I\in p(1)}\yon^{p[I]}\right)\;\tri\;
  \left(\sum_{J\in q(1)}\yon^{q[J]}\right)\coloneqq
  \sum_{I\in p(1)}\sum_{J\colon p[I]\to q(1)}\yon^{\sum_{i\in p[I]}q[J i]}.
\end{equation}
This gives a (nonsymmetric) monoidal structure $(\poly,\yon,\tri)$. One can see that a type in $p\tri q$ consists of a type $I\in p(1)$ and a type $(J i)\in q(1)$ for every term $i\in p[I]$. We denote such a type by $I\vdash J$. A term in it consists of a term $i\in p[I]$ and a term $j\in q[J i]$.

There is another monoidal product called \emph{Dirichlet product} and denoted $\otimes$; it is given by
\begin{equation}\label{eqn.dir_formula}
  \left(\sum_{I\in p(1)}\yon^{p[I]}\right)\otimes
  \left(\sum_{J\in q(1)}\yon^{q[J]}\right)\coloneqq
  \sum_{(I,J)\in p(1)\times q(1)}\yon^{p[I]\times q[J]}.
\end{equation}
This gives a symmetric monoidal structure $(\poly,\yon,\otimes)$. A type in $p\tri q$ is just a pair of types $(I,J)\in p(1)\times q(1)$ and a term of it is just a pair of terms $(i,j)\in p[I]\times q[J]$.

The $\otimes$ structure is symmetric. Both monoidal structures restrict to monoidal structures on $\polycart$; in other words any composite or Dirichlet product of cartesian morphisms is again cartesian.

\begin{proposition}\label{prop.indep}
The identity functor $\poly\to\poly$ can be regarded as a lax monoidal functor
\begin{equation}\label{eqn.indep}
	\indep\colon (\poly,\yon,\tri)\to(\poly,\yon,\otimes),
\end{equation}
Moreover the laxators (lax coherence maps), which we denote with the same symbol
\[\indep\colon (p\otimes q)\to (p\tri q)\]
are cartesian for any $p,q\in\poly$.
\end{proposition}
\begin{proof}
Suppose given polynomials $p,q\in\poly$ and a set $X\in\smset$; since $\indep$ is merely a lax monoidal structure atop the identity functor, the only data in it is in its laxator, which we define using \cref{rem.positions_and_directions} as follows.

On types, we send an index $(I,J)\in p(1)\times q(1)$ to $(I,J\_)\in p\tri q(\1)$, where $J_!\colon p[I]\to q(1)$ is constant $J$, sending each $i$ to $J\in q(1)$ Backwards on terms, we send $(i,j)\mapsto (i,j)$; indeed both \cref{eqn.comp_formula,eqn.dir_formula} have the same set of directions $\sum_{i\in p[I]}q[J]\cong p[I]\times q[J]$ when $J_!\coloneqq J$ is independent of $I$. Thus it is clear that $\indep$ is cartesian. We leave it to the reader to check the relevant axioms.
\end{proof}

\begin{proposition}\label{prop.tri_dir_cartesian}
Both the $\tri$ and the $\otimes$ products preserve cartesian maps.
\end{proposition}
\begin{proof}
Suppose given cartesian maps $\alpha\colon p_1\to p_2$ and $\beta\colon q_1\to q_2$. Then $\alpha\tri\beta$ is cartesian using the pullback definition \cref{def.poly} and $\alpha\otimes\beta$ is cartesian using the bijection-on-directions criterion from \cref{rem.positions_and_directions}.
\end{proof}

It follows from \cref{prop.tri_dir_cartesian} and the fact that $\otimes$ is a monoidal product that for any $u\in\poly$ the maps
\[
	\ol{\Phi}_u(p)(q)\coloneqq u\otimes p\tri q
	\qqand
	\Phi_u(p)(q)\coloneqq u\tri p\tri q
\]
defining the functors in \eqref{eqn.Phi} are functorial in $p\in\polycart$ and $q\in\poly$.

\begin{proposition}[$\kappa$-list monads]\label{prop.list_monad}
For any sum-product set $\kappa$, there is a cartesian monad structure $(\1,\Sigma)$ on the $\kappa$-list polynomial $u_\kappa\in\polycart$.
\end{proposition}
\begin{proof}
Recall that $u_\kappa=\sum_{N\in C_\kappa}\yon^N$, where $C_\kappa$ is a choice of one set for every cardinality $N<\kappa$, and that whenever $A<\kappa$ and $B_a<\kappa$ for each set in $(B_a)_{a\in A}$, the set $S(A,B)$ isomorphic to their disjoint union also satisfies $S(A,B)<\kappa$. 

The monoidal unit on $u_\kappa$ corresponds to the ordinal $\1<\kappa$, considered as a (cartesian) map $\yon\to u_\kappa$. The monoidal product $u_\kappa\tri u_\kappa\to u_\kappa$ sends $A\in u_\kappa(1)$ and $B\colon u_\kappa[A]\to u_\kappa(1)$ to $S(A,B)$. The monad laws are satisfied because coproduct is monoidal product and $u_\kappa$ has exactly one position (element in $C_\kappa$) for each cardinality $N<\kappa$. 
\end{proof}

\begin{definition}[$\kappa$-list monads]
For any sum-product set $\kappa$, we refer to the monad $(u_\kappa,\1,\Sigma)$ from \cref{prop.list_monad} as the \emph{$\kappa$-list monad}. Note that lax monoidal functors, such as $\indep$ from \eqref{eqn.indep}, send monoids to monoids. Hence, we also have a monoid structure 
\begin{equation}\label{eqn.otimes_monoid}
	\yon\To{\1} u
	\qqand
	u\otimes u\To{\indep} u\tri u\To{\Sigma}u.
\end{equation}
We denote it simply using parens: $(-,-)\colon u\otimes u\to u$.
\end{definition}

Our goal in the next section is to show that for any $\kappa$ as in \cref{ex.sum_prod_set}, the $\kappa$-list monad $(u_\kappa,\1,\Sigma)$ from \cref{prop.list_monad} is a universe in the sense of \cref{def.universe}.

%-------- Chapter --------%
\chapter{List monads are polynomial universes}

In this section, we will construct the lax monoidal functor
\[
	\Phi_u\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\poly),\id,\circ\Big)
\]
as we saw in \eqref{eqn.Phi}. The domain is the category $\polycart$ of polynomials and cartesian maps between them, and the codomain is $\en(\poly)$, the category of functors $\poly\to\poly$. The functors being lax monoidal with respect to $(\yon,\tri)$ means that there are maps
\begin{align*}
  q&\to\Phi(\yon)(q)
  &(\Phi(p_1)\circ\Phi(p_2))(q)&\to \Phi(p_1\tri p_2)(q)
\end{align*}
natural in $p_1,p_2,q$, satisfying the appropriate commutative diagrams.
What we need to understand is the lax monoidality of $\Phi_u$; these constrain $u$ for the first time.

%---- Section ----%
\section{The lax monoidal structure on $\Phi_u$}

\cref{def.switching} is the technical center of the paper, defining the switching map; the idea is that a universe $u$ should be able to absorb arbitrary dependencies into it. In \cref{lemma.key} we will capture the formal consequences of the switching map. Everything else in the paper is shuffling and unpacking these formal consequences. 

The unexpected thing about this map is that to define it requires we use what we call \emph{overflow}. It says that if you try to multiply too many things together, and the result is not a type in $u$, then define the result to be the empty type. One could instead restrict the domain (the sort of $p$ one is allowed to use), but then the statement becomes less attractive. We also think it is an interesting feature to include overflow values.

\begin{definition}[Switching transformation $\ol{\switch}$]\label{def.switching}
Let $u\coloneqq u_\kappa$ be a $\kappa$-list polynomial. Then for any $p\in\poly$ we define the \emph{switching transformation}
\[\ol{\switch}_{p}\colon p\tri(u\otimes -)\to u\otimes p\tri -\]
as follows.

Fix $q\in\polycart$. To give the component $\ol{\switch}\coloneqq\ol{\switch}_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q$, we first define its component $\ol{\switch}_1$ on positions. A position of $p\tri(u\otimes q)\to u\otimes p\tri q$ consists of a triple $(i,A,j)$ where $i\in p(1)$, $A\colon p[i]\to u(1)$, and $j\colon p[i]\to q(1)$. We want to define a position of $u\otimes p\tri q$, which consists of a triple $(A',i',j')$ where $A'\in u(1)$, $i'\in p(1)$, and $j'\colon p[i']\to q(1)$. We define $i'\coloneqq i$, $j'\coloneqq j$, and $A'$ as follows:
\begin{equation}\label{eqn.overflow}
  A'\coloneqq
  \begin{cases}
  	\Pi(p[i],A)&\tn{ if }\Pi(p[i],A)<\kappa\\
		0&\tn{ otherwise}
  \end{cases}
\end{equation}
In a case of $(i,A,j)$ for which the second condition is activated, we say that $\ol{\switch}$ \emph{overflows}; otherwise we say it \emph{succeeds}.

For the backwards map $\ol{\switch}^\sharp_{(i,A,j)}\colon (u\otimes p\tri q)[(A',i,j)]\to(p\tri(u\otimes q))[(i,A,j)]$ on directions, there are two cases. If $A'=0$ then $(u\otimes p\tri q)[(A',i,j)=0$, so there is a unique map; this is the sense in which ``overflow causes the system to halt''. Otherwise, we need a map
\begin{equation}\label{eqn.not_injective}
\prod_{s\in p[i]}A_s\times\sum_{s\in p[i]}q[js]\to\sum_{s\in p[i]}(A s)\times (js)
\end{equation}
and it is given by $(a,s,t)\mapsto(s,as,ts)$.%
\footnote{Note that the map $\ol{\switch}^\sharp_{(i,A,j)}$ is not generally injective, because for a given input $(a,s,t)$, most of the data in $a$ is discarded; hence $\ol{\switch}$ is not cartesian. This has nothing to do with overflow, and hence could not be avoided by merely restricting $\polycart$ to $\kappa$-bounded polynomials.}
\end{definition}

One can avoid the whole ``overflow'' issue by restricting the domain category throughout this paper to $\polycart_{<\kappa}\ss\polycart$, meaning that the switching map $\switch_p\colon p\tri u\to u\otimes p$ would be restricted only to those $p$ whose exponents have cardinality bounded by $\kappa$. We contemplated this move, but decided to allow arbitrary $p$ in order to imagine dependencies on ``real world'', or ``external'' parameters.

\begin{definition}[Switching map $\switch$]
Let $u\coloneqq u_\kappa$ be a $\kappa$-list polynomial. Then for any $p\in\poly$ we define the \emph{switching map}
\[\switch_p\colon p\tri u\to u\otimes p\]
to be the $\yon$-component of the switching transformation, $\switch_p\coloneqq\ol{\switch}_{p,\yon}$.
\end{definition}

The following lemma captures the key formal properties of the switching map. To prove it we will need the---so far unused---property of $\kappa$ that it is closed under its own products, i.e.\ that for any $A<\kappa$ and $(B_a)_{a\in A}$ with each $B_a<\kappa$, the product $\prod_{a\in A}B_a=\Pi(A,B)<\kappa$ is too.




\begin{lemma}[Key lemma]\label{lemma.key}
Let $u\coloneqq u_\kappa$ be the $\kappa$-list polynomial for a sum-product set $\kappa$. The switching map $\switch$ be defined as in \cref{def.switching} is natural
and the following diagrams commute:
\begin{gather}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&u\ar[dl, equal]\ar[dr, equal]\\
	\yon\tri u\ar[rr, "\switch_{\yon}"']\&\&u\otimes\yon
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&p\ar[dl, "p\tri\1"']\ar[dr,"\1\otimes p"]\\
	p\tri u\ar[rr, "\switch_{p}"']\&\&u\otimes p
\end{tikzcd}\label{eqn.key_smalls}
\\[15pt]
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri p'\tri u\ar[d, "p\tri\switch_{p'}"']\ar[r, "\switch_{p\tri p'}"]\&
	u\otimes p\tri p'\ar[r, "\indep\tri p'"]\&u\tri p\tri p'\\
	p\tri (u\otimes p')\ar[r, "p\tri \indep"']\&
	p\tri u\tri p'\ar[r, "\switch_{p}\tri p'"']\&
	(u\tri p)\tri p'\ar[u, "\indep\tri p'"']
\end{tikzcd}\label{eqn.key_med1}
\\[15pt]
\begin{tikzcd}[, ampersand replacement=\&, column sep=large]
	p\tri u\tri u\ar[r, "p\tri\Sigma"]\ar[d, "\switch_p\tri u"']\&
	p\tri u\ar[r, "\switch_p"]\&
	u\otimes p\ar[r, "\indep"]\&
	u\tri p\\
	(u\otimes p)\tri u\ar[r, "\indep\tri u"']\&
	u\tri p\tri u\ar[r, "u\tri\switch_p"']\&
	u\tri (u\otimes p)\ar[r, "u\tri\indep"']\&
	u\tri u\tri p\ar[u, "\Sigma\tri p"']
\end{tikzcd}\label{eqn.key_large}
\end{gather}
We record also a similar commutative diagram for the switching transformation $\ol{\switch}$:
\begin{gather}
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri (u\otimes u)\ar[d, "\ol{\switch}_{p',u}"']\ar[r, "p\tri{(-,-)}"]\&
	p\tri u\ar[r, "\switch_p"]\&u\otimes p\\
	u\otimes p\tri u\ar[rr, "u\otimes\switch_p"']\&\&
	u\otimes u\otimes p\ar[u, "{(-,-)}\tri p"']
\end{tikzcd}\label{eqn.key_med2}
\end{gather}
\end{lemma}
\begin{proof}
We begin with naturality. Clearly $\switch_p$ is natural in $q\in\poly$. Though the map $\switch_{p}$ would not be natural for arbitrary polynomial maps $\alpha\colon p\to p'$ because of the overflow, it is natural when $\alpha$ is cartesian. Indeed if $\alpha_1(i)=i'$ then the bijection $\alpha_i^\sharp$ extends to a bijection
\[\Pi(p[i],A)\cong\Pi(p'[i'],A)\]
and $\switch_p$ overflows iff $\switch_{p'}$ does.

We next consider the commutativity of the maps in \eqref{eqn.key_smalls}. The map $\yon\tri u\to u\otimes\yon$ sends $(\1,A)\mapsto\prod_{():\1}A()$, which is isomorphic to $A$ (and hence equal in$C_\kappa$). Thus the left hand triangle commutes. For the right-hand triangle, suppose given $i\in p(1)$. Under the left-hand composite map it is sent to $(\Pi(p[i],\1),i)$ and under the right-hand map it is sent to $(\1,i)$; these are the same element of $C_\kappa$, since $\Pi(p[i],\1)$ is defined isomorphic to a product of $\1$'s, which is isomorphic to $\1$. The maps on directions are also identical.

To prove that \eqref{eqn.key_med1} commutes, it suffices to show for any set $I$, sets $(I'_i)_{i\in I}$, and sets $(A_{i,i'})_{i\in I, i'\in I'_i}$ with $A_{i,i'}<\kappa$, that first there is a bijection
\[\Pi(\Sigma(I,I'),A)\cong\Pi(I,\Pi(I',A))\]
which there is, and that second the overflow handling agrees, as we now argue. If for any $i\in I$ there is an overflow in $\Pi(I'_i,A_i)$ then it will output $0$, and the product of anything with $0$ is $0$; hence the two sides agree that the result is $0$. Otherwise, if all $\Pi(I'_i,A_i)$ succeed, then if the mutual result is too big, both sides again agree that the result is $0$. 

To prove that \eqref{eqn.key_large} commutes, suppose given $(i,A,B)\in p\tri(u\tri u)$, where $A\colon p[i]\to u(1)$ and $B\colon\sum_{s:p[i]}As\to u(1)$. It is easy to check that under the top composite map it is sent to  $(A_1,i)$ and under the bottom composite map it is sent to $(A_2,i)$, for some $A_1,A_2\in u(1)$. Assuming neither overflows, these are 
\[
  A_1\cong\Pi(p[i],\Sigma(A, B))
  \qqand
	A_2\cong\Sigma(\Pi(p[i],A),\Pi(p[i],B))
\] 
respectively, and these sets are isomorphic (hence equal in $C_\kappa$). So it remains to deal with the overflow situations.

Note that $\Pi(p[i],\Sigma(A, B))\cong\Sigma(\Pi(p[i],A),\Pi(p[i],B))$ are bijective sets, so one overflows iff the other does. If they overflow then $\Pi(p[i],A\times B)>\kappa$ is too big, so $A_1=0$. In this case we also know that either $\Pi(p[i],A)>\kappa$ or $\Pi(p[i],Ba)>\kappa$ is too big, for some $a\in\Pi(p[i],A)$, by assumption on $\kappa$ (see \cref{def.sum_prod_set}). In the first case we will have $A_2=\Sigma(0,\Pi(p[i],B))$ and in the second case we will have $A_2=\Pi(p[i],\Sigma(A, 0))$; either way, the result is $0$. Hence the diagram commutes.

Finally to show that \eqref{eqn.key_med2} commutes, it suffices to show for any set $I$ and sets $(A_i)_{i\in I}$ and $(B_i)_{i\in I}$ with $A_i<\kappa$ and $B_i<\kappa$, that first there is a bijection 
\[\Pi(I,A\times B)\cong\Pi(I,A)\times\Pi(I,B)\]
which there is, and that second the overflow handling agrees. The argument is similar to the above.
\end{proof}

\begin{definition}[Dependent switching map $\varphi$]\label{def.dep_switching}
Let $u\coloneqq u_\kappa$ be a $\kappa$-list polynomial. For any polynomial $p\in\polycart$, define the \emph{dependent switching map}
\[
	\varphi_{p}\colon p\tri u\to u\tri p
\] 
as the composite of the independent switching map and the independent inclusion:
\[
	p\tri u\To{\switch_{p}}u\otimes p\To{\indep}u\tri p.
	\qedhere
\]
\end{definition}

\begin{theorem}
For any sum-product set $\kappa$, the $\kappa$-list monad is a universe for dependent types. 
\end{theorem}
\begin{proof}
Let $\kappa$ be a sum-product set, $u\coloneqq u_\kappa$ the associated list polynomial, and $(\1,\Sigma)$ the list monad structure; see \cref{def.sum_prod_set,prop.list_monad}. By \cref{def.universe} we need to show that the functor
\[
  \Phi\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\poly),\id,\circ\Big),
\]
given by $\Phi(p): q\mapsto u\tri p\tri q$, has a lax monoidal structure. Given $p_1,p_2\in\polycart$, we need to define the laxators, i.e.\ natural transformations
\[
	\phi\colon\id\to\Phi(\yon)
	\qqand
	\phi_{p_1,p_2}\colon\Phi(p_1)\circ\Phi(p_2)\to\Phi(p_1\tri p_2).
\]
We define their components $q\To{\phi_q} u\tri q$ and $u\tri p_1\tri u\tri p_2\tri q\To{\phi_{p_1,p_2, q}}u\tri p_1\tri p_2\tri q$ to be the dashed maps:
\[
\begin{tikzcd}
	q\ar[r, "\cong"]\ar[rd, bend right, dashed, "\phi_q"']&\yon\tri q\ar[d, "\1\tri q"]\\&
	u\tri q
\end{tikzcd}
\qqand
\begin{tikzcd}[column sep=50pt]
	u\tri p_1\tri u\tri p_2\tri q\ar[r, "u\tri\varphi_{p_1}\tri p_2\tri q"]\ar[dr, bend right=18pt, dashed, "\phi_{p_1,p_2,q}"']&
	u\tri u\tri p_1\tri p_2\tri q\ar[d, "\Sigma\tri p_1\tri p_2\tri q"]\\&
	u\tri p_1\tri p_2\tri q
\end{tikzcd}
\]

It remains to show that these satisfy the three commutative diagrams of a lax monoidal functor. The unit diagrams 
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\tri p\tri q\ar[r, "\phi_{u\tri p\tri q}"]\ar[dr, bend right=20pt, equal]\&
	u\tri u\tri p\tri q \ar[d, "\phi_{\yon,p,q}"]\\
	\&
	u\tri p\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\tri p\tri q\ar[r, "u\tri p\tri\phi_q"]\ar[dr, bend right=20pt, equal]\&
	u\tri p\tri u\tri q\ar[d, "\phi_{p,\yon,q}"]\\
	\&
	u\tri p\tri q
\end{tikzcd}
\]
commute by the monad unit laws and the commutativity of the right-hand triangle in \eqref{eqn.key_smalls}.

We conclude by showing that the associativity diagram commutes for any $q\in\poly$:
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=60pt]
	u\tri p_1\tri u\tri p_2\tri u\tri p_3\tri q
		\ar[r, "u\tri p_1\tri\phi_{p_2,p_3,q}"]
		\ar[d, "\phi_{p_1,p_2,u\tri p_3\tri q}"']\&
	u\tri p_1\tri u\tri p_2\tri p_3\tri q
		\ar[d, "\phi_{p_1,p_2\tri p_3,q}"]\\
	u\tri p_1\tri p_2\tri u\tri p_3\tri q
		\ar[r, "\phi_{p_1\tri p_2,p_3,q}"']\&
	u\tri p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]
Unpacking this, we obtain the following diagram, where the four sides above agree with the four composite sides shown:%
\footnote{We label the maps merely by ``hints'' for space reasons; e.g. the top maps labeled $\varphi$ and $\Sigma$ are fully written as $u\tri p_1\tri u\tri p_2\tri\varphi_{p_2}\tri p_3\tri q$ and $u\tri p_1\tri\Sigma\tri p_2\tri p_3\tri q$.}
\[%\fontsize{11pt}{11pt}\selectfont
\begin{tikzcd}
	u\tri p_1\tri u\tri p_2\tri u\tri p_3\tri q\ar[r, "\varphi"]\ar[dd, "\varphi"']&
	u\tri p_1\tri u\tri u\tri p_2\tri p_3\tri q\ar[r, "\Sigma"]\ar[d, "\varphi"]&
	u\tri p_1\tri u\tri p_2\tri p_3\tri q\ar[dd, "\varphi"]\\&
	u\tri u\tri p_1\tri u\tri p_2\tri p_3\tri q\ar[dd, "\varphi"]\\[-12pt]
	u\tri u\tri p_1\tri p_2\tri u\tri p_3\tri q\ar[dd, "\Sigma"']\ar[ur, bend left=5pt, start anchor={north east}, "\varphi"]\ar[dr, bend right=5pt, start anchor={south east}, "\varphi_{p_1\tri p_2}"']&&
	u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[dd, "\Sigma"]\\[-12pt]&
	u\tri u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[d, "\Sigma\tri u"]\ar[ur, bend right=5pt, start anchor={east}, end anchor={south west}, "u\tri\Sigma"']\\
	u\tri p_1\tri p_2\tri u\tri p_3\tri q\ar[r, "\varphi_{p_1\tri p_2}"']&
	u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[r, "\Sigma"]&
	u\tri p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]
The top-left and bottom-left squares commute by functoriality of monoidal products, and the bottom right square commutes by the monad associativity law. The rest is \cref{lemma.key}: the little triangle commutes by \eqref{eqn.key_med1} and the pentagon commutes by \eqref{eqn.key_large}.
\end{proof}


%-------- Chapter --------%
\chapter{Consequences in the language of dependent types}

The main theorem really just packages the story. The real heart of the matter---at least for dependent types---is \cref{lemma.key} applied to $u$ across the board, where $u$ is a polynomial universe as in \cref{def.universe}. So fix a polynomial universe $(u,\1,\Sigma)$ for the rest of this section.

%---- Section ----%
\section{Notation}

Our notation is not meant to be authoritative; the mathematics of polynomial functors takes care of the meaning, so that we can be more relaxed about how we want to represent it. The following is only meant to have the level of formality of a math paper, not of a logic or philosophy paper.

\paragraph{Type collections, types, terms, and dependencies.}
We refer to a polynomial $p\in\polycart$ as a \emph{type collection}. We refer to each element $I\in p(1)$ as a \emph{type}, and we refer to each element $i\in p[I]$ as a \emph{term of type $I$} and write $i:p[I]$.

We refer to $u$ as the \emph{type universe}; it is a type collection, but has more structure. Let $\U\coloneqq u(1)$ be the positions of the universe polynomial $u$. We denote each element of $\U$ using an upper-case letter, $A,B$, etc., and call it a \emph{base type}. Given a base type $A\in u(1)$, we denote $u[A]$ simply by $[A]$, since $u$ is fixed. We denote each element of $[A]$ using the same letter in lower-case, $a,a':[A]$, etc.; these are terms of type $A$.

We refer to $\yon$ as the \emph{unit} type collection. There is exactly one element of $\yon(1)$; we denote it $\1$. The set $\yon[\1]$ has a unique element, and we denote it $()$.

An element of $p\tri q(1)=(p\tri q)(1)$ consists of an element $I:p(1)$ and an element $J i:q(1)$ for every $i:p[I]$; we denote it by $(I\vdash J)\in (p\tri q)(1)$. Since $r\coloneqq p\tri q$ is a polynomial, $I\vdash J$ is just a type (an element of $r(1)$); however if we receive $r$ as a composite of $p$ and $q$ we may refer to $I\vdash J$ as a \emph{dependent type}: the $q$-type depends on a term of the $p$-type. A term of type $I\vdash J$ consists of a pair $(i,j)$ where $i:p[I]$ and $j: q[J i]$; we denote it $(i,j):(p\tri q)[I\vdash J]$.

An element of $(p\otimes q)(1)$ consists of a pair $(I,J)\in p(1)\times q(1)$; we call it a \emph{product type}. An element of $(p\otimes q)[(I,J)]$ consists of a pair $(i,j)\in p[I]\times q[J]$. 

\paragraph{Monoid structures on base types.}

The cartesian monoid structures $(u,\1,\Sigma)$ and $(u,\1,(-,-))$, and the map $\indep\colon u\otimes u\to u\tri u$, are denoted as follows. The map $\1\colon\yon\to u$ provides a certain base type, which we again call $\1\in U$. The map $\Sigma\colon u\tri u\to u$ provides a function $u\tri\U\to\U$, which we again call $\Sigma$. Thus for any dependent type $A\vdash B:u\tri\U$, we can form $\Sigma(A,B):\U$. Similarly the map $(-,-)\colon u\otimes u\to u$ provides a function $\U\times \U\to\U$, which we again denote $(-,-)$. Thus for any pair of types $(A,B):\U\times \U$ we can form $(A,B):\U$. 
\[
  \begin{prooftree}
    \Infer0{\1}
  \end{prooftree}
  \hspace{.6in} 
  \begin{prooftree}
    \Hypo{A, B}
    \Infer1{(A,B)}
  \end{prooftree}
\hspace{.6in}
  \begin{prooftree}
    \Hypo{A\vdash B}
    \Infer1{\Sigma(A,B)}
  \end{prooftree}
\]
Its cartesianness means that $\1$ has a single term, which we again call $():[\1]$. The cartesianness of $\Sigma$ means that a term of $\Sigma(A,B)$ consists of an element of $u\tri u[(A\vdash B)]$, i.e.\ a term $a:[A]$ and a term $b:[Ba]$. Similarly, a term of $(A,B)$ consists of an element $(a,b):[A]\times[B]$. From the third one, we can also write
\begin{equation}\label{eqn.dep_vs_sigma}
\begin{prooftree}
  \Infer0{(A\vdash B)\equiv \Sigma(A,B)}
\end{prooftree}
\end{equation}
which means that choosing a term of $A\vdash B$, meaning an $a:[A]$ and a $b:[B a]$, is the same thing as choosing a term of $\Sigma(A,B)$. The analogous statements for the first two say that the empty context has one element, and that choosing a term of $A,B$, meaning an $a:[A]$ and a $b:[B]$, is the same thing as choosing a term of $(A,B)$.


\paragraph{The switching transformation.}

Recall that for any $p\in\polycart$ and $q\in\poly$, \cref{def.switching} provides a morphism%
\footnote{As usual, $\tri$ binds the tightest, so $\U\times u\tri \U$ denotes $\U\times(u\tri \U)$.}
\[\switch_{p,q}\colon p\tri (u\otimes q)\to u\otimes p\tri q\]
Thus, given a dependent type $I\in p(1)$, a base type $A_i:\U$ and a type $J i\in q(1)$ for each $i\in p[I]$, we obtain a type denoted $(I\to A):\U$ (and we keep $I,J$ as before). In symbols,
\begin{equation*}
  \begin{prooftree}
    \Hypo{I\vdash (A, J)}
    \Infer1{I\to A, I\vdash J}
  \end{prooftree}
\end{equation*}
Given terms $a:[I\to A]$, $i:p[I]$, and $j:q[Ji]$, we obtain a term $(i,a i, j):p\tri(u\otimes q)[I\vdash (A,J)]$. Unlike the case for $\1$, $\Sigma$, and $(-,-)$, this construction is not a bijection because $\varphi_{u,u}$ is not cartesian, as explained in the footnote below \cref{eqn.not_injective}.

%---- Section ----%
\section{Unpacking the results}


Before we start, note that we already have the pairing laws from the fact that $(-,-)$ and $\Sigma$ are cartesian monads.
%\[
%\begin{array}{cc}
%	(A,\1)=A=(\1,A)&(A,(B,C))=((A,B),C)\\
%	\Sigma(A,\1)=A=\Sigma(\1,A)&
%		\Sigma(A,\Sigma(B,C))=\Sigma(\Sigma(A,B),C)
%\end{array}
%\]
\begin{gather*}
\begin{prooftree}
	\Hypo{A:\U}
	\Infer1{(A,\1)\equiv A\equiv (\1,A)}
\end{prooftree}
\hspace{.6in}
\begin{prooftree}
	\Hypo{A:\U}
	\Infer1{\Sigma(A,\1)\equiv A\equiv \Sigma(\1,A)}
\end{prooftree}
\\[10pt]
\begin{prooftree}
	\Hypo{A:\U}
	\Hypo{B:\U}
	\Hypo{C:\U}
	\Infer3{(A,(B,C))\equiv ((A,B),C)}
\end{prooftree}
\hspace{.6in}
\begin{prooftree}
	\Hypo{A:\U}
	\Hypo{B:\U}
	\Hypo{C:\U}
	\Infer3{\Sigma(A,\Sigma(B,C))\equiv \Sigma(\Sigma(A,B),C)}
\end{prooftree}
\end{gather*}

We now unpack the results from \cref{lemma.key}. The first two diagrams
\[
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&u\ar[dl, equal]\ar[dr, equal]\\
	\yon\tri u\ar[rr, "\switch_{\yon}"']\&\&u\otimes\yon
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&p\ar[dl, "p\tri\1"']\ar[dr,"\1\otimes p"]\\
	p\tri u\ar[rr, "\switch_{p}"']\&\&u\otimes p
\end{tikzcd}\label{eqn.key_smalls}
\]
is translated as:
\[
  \begin{prooftree}
    \Hypo{A : \U}
    \Infer1{(\1\to A)\equiv A}
  \end{prooftree}
  \hspace{.6in}
  \begin{prooftree}
    \Hypo{I : p(1)}
    \Infer1{(I\to \1)\equiv \1}
  \end{prooftree}
\]

The next diagram
\[
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri p'\tri u\ar[d, "p\tri\switch_{p'}"']\ar[r, "\switch_{p\tri p'}"]\&
	u\otimes p\tri p'\ar[r, "\indep\tri p'"]\&u\tri p\tri p'\\
	p\tri (u\otimes p')\ar[r, "p\tri \indep"']\&
	p\tri u\tri p'\ar[r, "\switch_{p}\tri p'"']\&
	(u\tri p)\tri p'\ar[u, "\indep\tri p'"']
\end{tikzcd}\label{eqn.key_med1}
\]
is translated as follows%
\footnote{Every time a type depends on terms of a previous type, we use a turnstyle $\vdash$; thus there may be several turnstyles in a type definition. Our notation simply follows the polynomial formalism in the sense that whenever we see $\tri$ in the polynomials, we see $\vdash$ in the types.
}

\[
  \begin{prooftree}
    \Hypo{I\vdash I'\vdash A:p\tri p'\tri \U}
    \Infer1{((I\vdash I')\to A)\equiv (I\to I'\to A)}
  \end{prooftree}
\]
This syntax, which includes a turnstyle in the domain of an arrow $(I\vdash I')\to A$, is unusual. But we can understand it in more classical notation below, either in its native form as to the left, or using \cref{eqn.dep_vs_sigma} which gives the equivalent form on the right:
\[
  \prod_{i:I,\; i':I' i}A i i'\;
  \equiv\;
  \prod_{i:I}\prod_{i':I' i}A i i'
  \equiv\;
  \prod_{(i,i'):\sum_{i:I}I' i}A (i,i')\;
\]

The next diagram
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=large]
	p\tri u\tri u\ar[r, "p\tri\Sigma"]\ar[d, "\switch\tri u"']\&
	p\tri u\ar[r, "\switch"]\&
	u\otimes p\ar[r, "\indep"]\&
	u\tri p\\
	(u\otimes p)\tri u\ar[r, "\indep\tri u"']\&
	u\tri p\tri u\ar[r, "u\tri\switch"']\&
	u\tri (u\otimes p)\ar[r, "u\tri\indep"']\&
	u\tri u\tri p\ar[u, "\Sigma\tri p"']
\end{tikzcd}
\]
is translated as
\[
  \begin{prooftree}
    \Hypo{I\vdash A\vdash B : p\tri u\tri \U}
    \Infer1{I\to\Sigma(A,B)\equiv\Sigma(I\to A,I\to B)}
  \end{prooftree}
\]

The final diagram is quite similar, but for independent types $A,B$:
\[
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri (u\otimes u)\ar[d, "\ol{\switch}_{p',u}"']\ar[r, "p\tri{(-,-)}"]\&
	p\tri u\ar[r, "\switch_p"]\&u\otimes p\\
	u\otimes p\tri u\ar[rr, "u\otimes\switch_p"']\&\&
	u\otimes u\otimes p\ar[u, "{(-,-)}\tri p"']
\end{tikzcd}\label{eqn.key_med2}
\]
It is translated as
\[
  \begin{prooftree}
    \Hypo{I\vdash (A, B) : p\tri(\U\otimes\U)}
    \Infer1{I\to(A,B)\equiv(I\to A,I\to B)}
  \end{prooftree}
\]


%\[
%\begin{tabular}{p{3in}|p{2in}}
%	naturality with respect to $p\in\polycart$,\\applied to $\Sigma\colon u\tri u\to u$&
%		\\
%	naturality with respect to $\indep$&
%		\\
%	commutation with composition&
%		\\
%	the first diagram&
%		\\
%	the second diagram&
%		
%\end{tabular}
%\]










\printbibliography
\end{document}
