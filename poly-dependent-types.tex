\documentclass[11pt, one side, article]{memoir}


\settrims{0pt}{0pt} % page and stock same size
\settypeblocksize{*}{34.5pc}{*} % {height}{width}{ratio}
\setlrmargins{*}{*}{1} % {spine}{edge}{ratio}
\setulmarginsandblock{.98in}{.98in}{*} % height of typeblock computed
\setheadfoot{\onelineskip}{2\onelineskip} % {headheight}{footskip}
\setheaderspaces{*}{1.5\onelineskip}{*} % {headdrop}{headsep}{ratio}
\checkandfixthelayout


\usepackage{amsthm}
\usepackage{mathtools}

\usepackage[inline]{enumitem}
\usepackage{ifthen}
\usepackage[utf8]{inputenc} %allows non-ascii in bib file
\usepackage{xcolor}

\usepackage[backend=biber, backref=true, maxbibnames = 10, style = alphabetic]{biblatex}
\usepackage[bookmarks=true, colorlinks=true, linkcolor=blue!50!black,
citecolor=orange!50!black, urlcolor=orange!50!black, pdfencoding=unicode]{hyperref}
\usepackage[capitalize]{cleveref}

\usepackage{tikz}

\usepackage{amssymb}
\usepackage{newpxtext}
\usepackage[varg,bigdelims]{newpxmath}
\usepackage{mathrsfs}
\usepackage{dutchcal}
\usepackage{fontawesome}
\usepackage{ebproof}



% cleveref %
  \newcommand{\creflastconjunction}{, and\nobreakspace} % serial comma
  \crefformat{enumi}{\##2#1#3}
  \crefalias{chapter}{section}


% biblatex %
  \addbibresource{Library20211226.bib} 

% hyperref %
  \hypersetup{final}

% enumitem %
  \setlist{nosep}
  \setlistdepth{6}



% tikz %



  \usetikzlibrary{ 
  	cd,
  	math,
  	decorations.markings,
		decorations.pathreplacing,
  	positioning,
  	arrows.meta,
  	shapes,
		shadows,
		shadings,
  	calc,
  	fit,
  	quotes,
  	intersections,
    circuits,
    circuits.ee.IEC
  }
  
  \tikzset{
biml/.tip={Glyph[glyph math command=triangleleft, glyph length=.95ex]},
bimr/.tip={Glyph[glyph math command=triangleright, glyph length=.95ex]},
}

\tikzset{
	tick/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (0,.4ex) -- (0,-.4ex);}}}
  }
} 
\tikzset{
	slash/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (.3ex,.3ex) -- (-.3ex,-.3ex);}}}
  }
} 

\newcommand{\bito}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, biml-bimr, "#1"]\&~\end{tikzcd}  
}
\newcommand{\bifrom}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, bimr-biml, "{#1}"]\&~\end{tikzcd}  
}
\newcommand{\bifromlong}[2][]{
	\begin{tikzcd}[ampersand replacement=\&, column sep=#2, cramped]\ar[r, bimr-biml, "#1"]\&~\end{tikzcd}  
}

% Adjunctions
\newcommand{\adj}[5][30pt]{%[size] Cat L, Left, Right, Cat R.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]
  \ar[r, phantom, "\scriptstyle\Rightarrow"]\&
  #5\ar[l, shift left=7pt, "#4"]
\end{tikzcd}
}

\newcommand{\adjr}[5][30pt]{%[size] Cat R, Right, Left, Cat L.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]\&
  #5\ar[l, shift left=7pt, "#4"]
  \ar[l, phantom, "\scriptstyle\Leftarrow"]
\end{tikzcd}
}

\newcommand{\xtickar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}
\newcommand{\xslashar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}



  
  % amsthm %
\theoremstyle{definition}
\newtheorem{definitionx}{Definition}[chapter]
\newtheorem{examplex}[definitionx]{Example}
\newtheorem{remarkx}[definitionx]{Remark}
\newtheorem{notation}[definitionx]{Notation}


\theoremstyle{plain}

\newtheorem{theorem}[definitionx]{Theorem}
\newtheorem{proposition}[definitionx]{Proposition}
\newtheorem{corollary}[definitionx]{Corollary}
\newtheorem{lemma}[definitionx]{Lemma}
\newtheorem{warning}[definitionx]{Warning}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{proposition*}{Proposition}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{warning*}{Warning}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{construction}[theorem]{Construction}

\newenvironment{example}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\examplex}
  {\popQED\endexamplex}
  
 \newenvironment{remark}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\remarkx}
  {\popQED\endremarkx}
  
  \newenvironment{definition}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\definitionx}
  {\popQED\enddefinitionx} 

    
%-------- Single symbols --------%
	
\DeclareSymbolFont{stmry}{U}{stmry}{m}{n}
\DeclareMathSymbol\fatsemi\mathop{stmry}{"23}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}


%-------- Renewed commands --------%

\renewcommand{\ss}{\subseteq}

%-------- Other Macros --------%


\DeclarePairedDelimiter{\present}{\langle}{\rangle}
\DeclarePairedDelimiter{\copair}{[}{]}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\corners}{\ulcorner}{\urcorner}
\DeclarePairedDelimiter{\ihom}{[}{]}

\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Mor}{Mor}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\idy}{idy}
\DeclareMathOperator{\comp}{com}
\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\ob}{Ob}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\el}{El}




\newcommand{\const}[1]{\texttt{#1}}%a constant, or named element of a set
\newcommand{\Set}[1]{\mathsf{#1}}%a named set
\newcommand{\ord}[1]{\mathsf{#1}}%an ordinal
\newcommand{\cat}[1]{\mathcal{#1}}%a generic category
\newcommand{\Cat}[1]{\mathbf{#1}}%a named category
\newcommand{\fun}[1]{\mathrm{#1}}%a function
\newcommand{\Fun}[1]{\mathit{#1}}%a named functor




\newcommand{\id}{\mathrm{id}}
\newcommand{\then}{\mathbin{\fatsemi}}

\newcommand{\cocolon}{:\!}


\newcommand{\iso}{\cong}
\newcommand{\too}{\longrightarrow}
\newcommand{\tto}{\rightrightarrows}
\newcommand{\To}[2][]{\xrightarrow[#1]{#2}}
\renewcommand{\Mapsto}[1]{\xmapsto{#1}}
\newcommand{\Tto}[3][13pt]{\begin{tikzcd}[sep=#1, cramped, ampersand replacement=\&, text height=1ex, text depth=.3ex]\ar[r, shift left=2pt, "#2"]\ar[r, shift right=2pt, "#3"']\&{}\end{tikzcd}}
\newcommand{\Too}[1]{\xrightarrow{\;\;#1\;\;}}
\newcommand{\from}{\leftarrow}
\newcommand{\ffrom}{\leftleftarrows}
\newcommand{\From}[1]{\xleftarrow{#1}}
\newcommand{\Fromm}[1]{\xleftarrow{\;\;#1\;\;}}
\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\inj}{\rightarrowtail}
\newcommand{\wavyto}{\rightsquigarrow}
\newcommand{\lollipop}{\multimap}
\newcommand{\imp}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\down}{\mathbin{\downarrow}}
\newcommand{\fromto}{\leftrightarrows}
\newcommand{\tickar}{\xtickar{}}
\newcommand{\slashar}{\xslashar{}}



\newcommand{\inv}{^{-1}}
\newcommand{\op}{^\tn{op}}

\newcommand{\tn}[1]{\textnormal{#1}}
\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\wc}[1]{\widecheck{#1}}
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}



\newcommand{\bb}{\mathbb{B}}
\newcommand{\cc}{\mathbb{C}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\pp}{\mathbb{P}}
\newcommand{\qq}{\mathbb{Q}}
\newcommand{\zz}{\mathbb{Z}}
\newcommand{\rr}{\mathbb{R}}


\newcommand{\finset}{\Cat{Fin}}
\newcommand{\smset}{\Cat{Set}}
\newcommand{\smcat}{\Cat{Cat}}
\newcommand{\catsharp}{\Cat{Cat}^{\sharp}}
\newcommand{\ppolyfun}{\mathbb{P}\Cat{olyFun}}
\newcommand{\ccatsharp}{\mathbb{C}\Cat{at}^{\sharp}}
\newcommand{\ccatsharpdisc}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc}}}
\newcommand{\ccatsharplin}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{lin}}}
\newcommand{\ccatsharpdisccon}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc,con}}}
\newcommand{\sspan}{\mathbb{S}\Cat{pan}}
\newcommand{\en}{\Cat{End}}

\newcommand{\List}{\Fun{List}}
\newcommand{\set}{\tn{-}\Cat{Set}}




\newcommand{\yon}{\mathcal{y}}
\newcommand{\poly}{\Cat{Poly}}
\newcommand{\polycart}{\poly^{\Cat{Cart}}}
\newcommand{\ppoly}{\mathbb{P}\Cat{oly}}
\newcommand{\0}{\textsf{0}}
\newcommand{\1}{\tn{\textsf{1}}}
\newcommand{\U}{\tn{\textsf{U}}}
\newcommand{\tri}{\mathbin{\triangleleft}}
\newcommand{\triright}{\mathbin{\triangleright}}
\newcommand{\tripow}[1]{^{\tri #1}}
\newcommand{\indep}{\Fun{Indep}}
\newcommand{\duoid}{\Fun{Duoid}}
\newcommand{\switch}{\pi}


% lenses
\newcommand{\biglens}[2]{
     \begin{bmatrix}{\vphantom{f_f^f}#2} \\ {\vphantom{f_f^f}#1} \end{bmatrix}
}
\newcommand{\littlelens}[2]{
     \begin{bsmallmatrix}{\vphantom{f}#2} \\ {\vphantom{f}#1} \end{bsmallmatrix}
}
\newcommand{\lens}[2]{
  \relax\if@display
     \biglens{#1}{#2}
  \else
     \littlelens{#1}{#2}
  \fi
}



\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\qqand}{\qquad\text{and}\qquad}


\newcommand{\coto}{\nrightarrow}
\newcommand{\cofun}{{\raisebox{2pt}{\resizebox{2.5pt}{2.5pt}{$\setminus$}}}}

\newcommand{\coalg}{\tn{-}\Cat{Coalg}}

\newcommand{\bic}[2]{{}_{#1}\Cat{Comod}_{#2}}

% ---- Changeable document parameters ---- %

\linespread{1.1}
\allowdisplaybreaks
\setsecnumdepth{section}
\settocdepth{section}
\setlength{\parindent}{15pt}
\setcounter{tocdepth}{1}



%--------------- Document ---------------%
\begin{document}

\title{Polynomial universes:\\Syntax and conversions for dependent types}

\author{David I. Spivak}

\date{\vspace{-.2in}}

\maketitle

\begin{abstract}
\end{abstract}


%-------- Chapter --------%
\chapter{Introduction}



Dependent type theory \cite{martin-lof1975intuitionistic} was founded by Per Martin-L\"{o}f in 1975 to formalize constructive mathematics. The basic idea is that \emph{order of events} is fundamental to a mathematical story arc: when playing out any specific example story in that arc, the beginning of the story affects not only the later events, but even the very terms with which the later events will be described. For example, in the story arc of conditional probability, one may say ``now if the set $P$ that we are asked to condition on happens to have measure zero, we must stop; but assuming that's not the case then the result will be a new probability measure.'' Here the story teller is saying that no terms will describe what happens if $P$ has measure zero, whereas otherwise the terms of standard probability will apply.

Dependent types form a logical system with syntax, conversion rules, and methods of deduction. In \cite{awodey2014natural,awodey2018polynomial}, Awodey and later Newstead show that there is a strong connection between dependent type theory and polynomial functors. The present work follows from this remarkable discovery, but diverges in the formalism itself. Whereas they discuss pseudomonads and pseudo-algebras in a tri-category arising from a locally cartesian closed category, we keep simply to lax monoidal functors and transformations between monoidal categories. In both cases, the focus is on the syntax and conversion rules of dependent type theory, not the universal properties that yield valid deductions.

A polynomial functor $p\colon\smset\to\smset$ is a coproduct of representable functors
\[\sum_{I\in p(1)}\yon^{p[I]},\]
which one can think of as a collection of types: A position $I\in p(1)$ indexing the coproduct corresponds to a \emph{type} in the collection, and an element $i\in p[I]$ in the representing set $p[I]$ corresponds to a \emph{term} of type $I$. 

Under this system, composition $p\tri q$ of polynomials corresponds to dependent types: in order to choose a type $x\in (p\tri q)(1)$ in the composite, you must first choose a type $I\in p(1)$ and then, for any term $i\in p[I]$ of it you choose a type $J:q(1)$. In this paper (not in the literature) we denote this situation by $I\vdash J$. 

For example, suppose
\[
  p=\{{'0'}\}\yon^0+\{{'1'}\}\yon^1
  \qqand 
  q=\sum_{N\in\nn}\sum_{\{D\colon N\to\rr_{\geq 0}\mid D_1+\cdots+D_N=1\}}\yon^N.
\]
Then to choose an element $I\vdash J\in (p\tri q)(1)$, you \emph{first} make a binary choice ${'0'}$ or ${'1'}$; that's the type $I\in p(1)$. Then the next type $J$ depends on your choice. Indeed, in the ${'0'}$-case you have already hit the end of the story---you stop---and in the ${'1'}$-case you \emph{further} make choice of $N\in\nn$ and a probability distribution $D$ on a set with $N$ elements. All together, whichever branch you took, the result is a type $I\vdash J$ in the collection $p\tri q$. This type has \emph{no terms} in the ${'0'}$-case, and it has $N$-many terms in the ${'1'}$-case.

A special case of dependent types is \emph{independent} types, where the order of this part of the story \emph{doesn't} matter. These are represented using a symmetric monoidal product $\otimes$ on polynomial functors: for any $p,q$ one can form $p\otimes q$ and there is an isomorphism $p\otimes q\cong q\otimes p$. The types in the family $p\otimes q$ are pairs of types $(I,J)\in p(1)\times q(1)$, and the terms of type $(I,J)$ are pairs of terms $(i,j)\in p[I]\times q[J]$. There is a natural map $\indep\colon(p\otimes q)\to (p\tri q)$ allowing us to regard a pair $(I,J)$ of independent types as a dependent type $(I\vdash J)\coloneqq\indep(I,J)$.

In this paper we explain the notion of a \emph{polynomial universe} $u$,%
\footnote{Again, this notion is due to \cite[Theorem 16]{awodey2014natural}, where he calls them ``natural model of extensional Martin-L\"{o}f type theory with
product, sum, and identity types''. We focus on what that paper would call the $\mathbb{C}=1$ case, meaning that everything in this paper takes place in $\smset$ rather than an arbitrary presheaf category.}
with which one can reduce all the dependencies by collapsing an arbitrarily deep dependent type into a single layer. In particular we will be intersted in a particular map
\begin{equation}\label{eqn.switch}
  \switch_p\colon p\tri u\to u\otimes p
\end{equation}
that converts dependent types into independent types by sending $I\vdash A$ to the pair $(I\to A,A)$, where $I\to A$ might be called the \emph{dependent product type} or \emph{dependent function type}.%
\footnote{This is just a terminological preference: a product $\prod_{a\in A}B$ of $A$-many copies of $B$ is also a function $A\to B$; in both cases the number of $B$'s could depend on the choice of $a\in A$. Allowing ones terminology to depend on ones preferences is a meta-version of this whole story.}
It is as though $u$ is able to absorb the effect of $p$-dependencies into itself, a move which in some sense makes computations into ``first-class objects". When $p=u$ we can convert a dependent type $(A\vdash B)\in u\tri u(1)$ all the way to a base type $(A\to B,A)\in u(1)$ by first absorbing the dependency and then composing with a pairing operation $u\tri u\To{\switch_u} u\otimes u\To{(-,-)} u$.

In this paper we will see that syntax and conversion rules of dependent types  emerge from the very special properties enjoyed by these polynomial universes $u$. Not only should a polynomial universe carry the structure of a cartesian monad, which gives it a unit type $\1$ and $\Sigma$ types, but these must distribute properly over function types. All this is packaged in the following definition.

\begin{definition}[Polynomial universe]\label{def.universe}
Let $(u,\1,\Sigma)$ be a cartesian polynomial monad. We say it is a \emph{polynomial universe} if there exists a diagram of the form
\begin{equation}\label{eqn.Phi}
\begin{tikzcd}[column sep=60pt]
	\Big(\polycart,\yon,\tri\Big)
		\ar[r, bend left=15pt,  start anchor={north east}, end anchor={north west}, "\ol{\Phi}_u", ""' name=P]
		\ar[r, bend right=15pt, start anchor={south east}, end anchor={south west}, "\Phi_u"', "" name=PP]&
	\Big(\en(\poly),\id,\circ\Big)
	\ar[from=P, to=P|-PP, Rightarrow, shorten=2mm, "\indep"]
\end{tikzcd}
\end{equation}
where the functors $\ol{\Phi}_u$ and $\Phi_u$ have a lax monoidal structure and are given by
\begin{equation}\label{eqn.olphi_phi}
\ol{\Phi}_u(p)(q)\coloneqq u\otimes p\tri q
\qqand
\Phi_u(p)(q)\coloneqq u\tri p\tri q
\end{equation}
and the natural transformation also has a monoidal structure and is given by
\[
  u\otimes p\tri q\To{\indep\tri q} u\tri p\tri q.
  \qedhere
\]
\end{definition}

The purpose of the remainder of this paper is to explain all this, so readers should not be concerned if they have lost the connection; our goal now is just to give a sense of the packaging. The crux of the story is that polynomial universes $u$ are things that can coherently absorb arbitrary dependencies into themselves, making computations into first-class types.

In the text below we will give examples of polynomial universes; probably the best known is the list monad
\[
	u_\nn\coloneqq\sum_{N\in\nn}\yon^N
\]
which has a notion of singleton list and a way to concatenate lists of lists into a list, e.g.\ sending $[[1,2,3],[4,5]]\mapsto [1,2,3,4,5]$. But one can also perform the following operation: given a list of lists, one can \emph{list out} all the ways to choose one element from each, e.g.
\[
[[1,2,3],[4,5]]\mapsto [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]].
\]
Let's call this operation \emph{cross-sectioning}. Anyway, the ways these two operations---concatenating and cross-sectioning---work together coherently with various associative, distributive, unital, and other properties. This structure is at the heart of dependent type theory and emerges directly from \cref{def.universe}.

To explain at a high level, let's fix some polynomial universe $(u,\1,\Sigma)$ and write $\Phi$ for $\Phi_u$, etc. The absorption of arbitrary dependencies into $u$ is packaged up into the coherence maps---the \emph{laxators}---of the lax monoidal structure on $\Phi$ and $\ol{\Phi}$. They are of the form
\[
\Phi(p_1)\circ\Phi(p_2)
\Too{\phi_{p_1,p_2}}
\Phi(p_1\tri p_2).
\]
The laxators are formed using the $\switch$-maps described above in \eqref{eqn.switch} and give rise to type- and term-forming operations for dependent function types. The unitality and associativity laws governing $\Phi$ and $\ol{\Phi}$ give rise to the conversion rules between them. For example, from them one can derive a self-distributivity law $u\tri u\to u\tri u$, as discussed in a July 2021 \href{https://topos.site/blog/2021/07/jump-monads-from-conjugation-to-dependent-types/}{Topos Institute blog post}.

As mentioned there, the germination of this idea came from \href{https://www.youtube.com/watch?v=RDuNIP4icKI\&t=10765s}{Steve Awodey's talk} at the 2021 Workshop on Polynomial Functors on his theory of natural models and their connection to polynomial functors. Aside from a very different presentation (e.g.\ lax monoidal functors here in place of pseudomonads there, the present work adds two things:
\begin{enumerate}
	\item explicit syntax and rules for pair types, and
	\item the distributive law of $\Pi$ over $\Sigma$, which in the language of \cite{awodey2018polynomial} would say%
	\footnote{In our language it would say 
	\[
	A\to\Sigma(B,C)\cong \Sigma(A\to B,A\to C).
	\]
	}
	\begin{equation}\label{eqn.distributivity_law_we_all_love}
	\prod_{x:A}\sum_{y:B(x)}C(x,y)\cong\sum_{y:\prod_{x:A}B(x)}\prod_{x:A}C(x,y(x)).
	\end{equation}
	Awodey and Newstead derived the other law connecting $\Sigma$ and $\Pi$ in their paper (see \cite[Remark 4.2]{awodey2018polynomial}), but under our reading of it, they seem to be missing the one in \eqref{eqn.distributivity_law_we_all_love}.%
	\footnote{\href{https://youtu.be/RDuNIP4icKI?t=13898}{Andr\'{e} Joyal's question following Steve Awodey's talk} was ``what happened to the distributivity law that we love between sum and product?" Steve said that he believed it was of the same form as the other laws they had derived, and that they get it for free. I have not seen this derivation, but it may be coming from universal properties. Since neither this nor \cite{awodey2018polynomial} consider universal properties of dependent types, just their formation and rules, we hope that the present paper will be of interest.
	}
\end{enumerate}

%---- Section ----%
\section{Acknowledgments}

I greatly appreciate the clarity of delivery and the insight behind Steve Awodey's talk at the 2021 Workshop on Polynomial Functors. It has been a major source of inspiration and fun during the intervening year. 

This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-20-1-0348.

%-------- Chapter --------%
\chapter{Background and key examples}

The main purpose of this section is to fix notation and provide a brief overview of polynomial functors in one variable. More extensive background material can be found in \cite{spivak2022poly} and \cite{kock2012polynomial}. We will also use the present section to introduce our main polynomials of interest, which we call $\kappa$-list polynomials.

%---- Section ----%
\section{Basics}

\begin{definition}[Polynomial functor]\label{def.poly}
Given a set $S$, we denote the corresponding representable functor by
\[\yon^S\coloneqq\smset(S,-)\colon\smset\to\smset,\]
e.g. $\yon^S(X)\coloneqq X^S$. In particular $\yon=\yon^1$ is the identity and $\yon^0=1$ is constant singleton.

A \emph{polynomial functor} is a functor $p\colon\smset\to\smset$ that is isomorphic to a sum of representables, i.e.\ for which there exists a set $T$, a set $p[t]\in\smset$ for each $t\in T$, and an isomorphism
\[
p\cong\sum_{t\in T}\yon^{p[t]}.
\]
We call $T$ the set of \emph{$p$-types}, and for each type $t\in T$ we call $p[t]$ the set of \emph{$p$-terms of type $t$}. 

A \emph{morphism} $\varphi\colon p\to p'$ of polynomial functors is simply a natural transformation between them. We denote the category of polynomial functors by $\poly$. It is called \emph{cartesian} if for every map of sets $f\colon S\to S'$, the naturality square
\[
\begin{tikzcd}
  p(S)\ar[r, "p(f)"]\ar[d, "\varphi(S)"']&p(S)\ar[d, "\varphi(S')"]\\
  p'(S')\ar[r, "p'(f)"']&p'(S')\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\]
is a pullback of sets. We denote the wide subcategory of polynomials and cartesian maps by $\polycart$.
\end{definition}

For any polynomial $p=\sum_{t\in T}\yon^{p[t]}$, we have a canonical isomorphism $p(1)\cong T$; hence we will denote $p$ by
\begin{equation}\label{eqn.poly_notation}
p=\sum_{I\in p(1)}\yon^{p[I]}
\end{equation}
so that the $p$-types are written with upper-case letters.

\begin{remark}
Note that there is already some dependency in \cref{def.poly}; in order to define a polynomial we need a set $T$ and then, \emph{for each $t$ in $T$}, we need a representable functor. Thus we can use polynomial functors to explicate the syntax and rules of dependent types, but only if our meta-theory allows us to already know what dependent types are.
\end{remark}

\begin{remark}\label{rem.positions_and_directions}
Using the Yoneda lemma, we can understand a morphism $p\to q$ in $\poly$ to consist of two pieces $(\varphi_1,\varphi^\sharp)$ as follows:
\begin{equation}\label{eqn.mapsharp}
  \varphi_1\colon p(1)\to q(1)
  \qqand
  \varphi^\sharp_I\colon q[J]\to p[I]
\end{equation}
that is, $\varphi_1$ is a function on positions, and $\varphi^\sharp_i$ is a function on directions, \emph{depending on a position $I\in p(1)$}, where $\varphi_1 i=j$.%
\footnote{
In this paper, we generally denote \emph{function} application by juxtaposition, e.g.\ for $f\colon A\to B$ we write $fa\in B$ rather than $f(a)$ for the image of $a$ under $f$. However, we denote \emph{functor} application using parentheses, e.g.\ $p(1)$ to denote $p\colon\smset\to\smset$ applied to $1=\{{'1'}\}$ in $\smset$.
}
We refer to $\varphi_1$ as the \emph{on-types function} and to $\varphi^\sharp$ as the \emph{backwards on-terms} function.

One can check that a map $\varphi\colon p\to q$ is cartesian iff the backwards-on-terms function $\varphi^\sharp_I$ is a bijection $p[I]\cong q[\varphi_1I]$ for each type $I\in p(1)$.
\end{remark}



\begin{definition}[Sum-product sets and list polynomials]\label{def.sum_prod_set}
Let $\kappa$ be a set. We say that it is a \emph{sum-product set} if it satisfies the following properties for any sets $A$ and $(B_a)_{a\in A}$ with disjoint union $S(A,B)\coloneqq\coprod_{a\in A}B_a$ and cartesian product $\Pi(A,B)\coloneqq\prod_{a\in A}B_a$:%
\footnote{We write $S(A,B)$ rather than $\Sigma(A,B)$ because we already have used that symbol for a monad structure. Later we will define $\Sigma(A,B)$ to be this $S(A,B)$, so the distinction is not important.}
\begin{enumerate}[label=(\roman*)]
	\item $\kappa$ is nonempty $0<\kappa$;
	\item $\kappa$ is closed under its own sums: if $A<\kappa$ and each $B_a<\kappa$, then $S(A,B)<\kappa$;
	\item $\kappa$ is closed under its own products: if $A<\kappa$ and each $B_a<\kappa$, then $\Pi(A,B)<\kappa$;
	\item there exists a set $C_\kappa$ containing exactly one set of each cardinality $N<\kappa$.%
	\footnote{The set $C_\kappa$ is structure, not property, but any two choices will yield isomorphic list polynomials, so we are not concerned with the distinction here.}
\end{enumerate}

Given a sum-product set $\kappa$, we define the \emph{$\kappa$-list polynomial} to be
\[
  u_\kappa\coloneqq\sum_{N\in C_\kappa}\yon^N
\qedhere
\]
\end{definition}

\begin{example}\label{ex.sum_prod_set}
Given the axiom of choice, any Grothendieck universe is a sum-product set; indeed conditions (i) -- (iii) are satisfied for any Grothendieck universe, and (iv) is satisfied assuming the axiom of choice.

There is only one finite ordinal with the above properties, namely $\kappa=2$. Indeed, $0$ fails condition (i), $1$ fails condition (iii) because $\Pi(0,!)=1\not<1$, and any $2<\kappa<\omega$ fails condition (ii) because by induction $\Pi(\kappa-1,(\kappa-1,\kappa-1))\not<\kappa$.

The easiest intuitive example to keep in mind for our paper is $\kappa=\nn$,%
\footnote{We write $\nn$ rather than $\omega$ for the set of natural numbers, the first infinite ordinal.} so that $N<\nn$ iff $N$ is finite. The $\nn$-list polynomial is
\[
  u_\nn\coloneqq\sum_{N\in\nn}\yon^N.
\qedhere
\]
\end{example}

%---- Section ----%
\section{Composition and Dirichlet monoidal structures}

Polynomial functors are closed under composition, which we denote by $\tri$; its types and terms are given by the following formula:
\begin{equation}\label{eqn.comp_formula}
  \left(\sum_{I\in p(1)}\yon^{p[I]}\right)\;\tri\;
  \left(\sum_{J\in q(1)}\yon^{q[J]}\right)\coloneqq
  \sum_{I\in p(1)}\sum_{J\colon p[I]\to q(1)}\yon^{\sum_{i\in p[I]}q[J i]}.
\end{equation}
This gives a (nonsymmetric) monoidal structure $(\poly,\yon,\tri)$. One can see that a type in $p\tri q$ consists of a type $I\in p(1)$ and a type $(J i)\in q(1)$ for every term $i\in p[I]$. We denote such a type by $I\vdash J$. A term in it consists of a term $i\in p[I]$ and a term $j\in q[J i]$.

There is another monoidal product called \emph{Dirichlet product} and denoted $\otimes$; it is given by
\begin{equation}\label{eqn.dir_formula}
  \left(\sum_{I\in p(1)}\yon^{p[I]}\right)\otimes
  \left(\sum_{J\in q(1)}\yon^{q[J]}\right)\coloneqq
  \sum_{(I,J)\in p(1)\times q(1)}\yon^{p[I]\times q[J]}.
\end{equation}
This gives a symmetric monoidal structure $(\poly,\yon,\otimes)$. A type in $p\tri q$ is just a pair of types $(I,J)\in p(1)\times q(1)$ and a term of it is just a pair of terms $(i,j)\in p[I]\times q[J]$.

The $\otimes$ structure is symmetric. Both monoidal structures restrict to monoidal structures on $\polycart$; in other words any composite or Dirichlet product of cartesian morphisms is again cartesian.

\begin{proposition}\label{prop.tri_dir_cartesian}
Both the $\tri$ and the $\otimes$ products preserve cartesian maps.
\end{proposition}
\begin{proof}
Suppose given cartesian maps $\alpha\colon p_1\to p_2$ and $\beta\colon q_1\to q_2$. Then $\alpha\tri\beta$ is cartesian using the pullback definition \cref{def.poly} and $\alpha\otimes\beta$ is cartesian using the bijection-on-directions criterion from \cref{rem.positions_and_directions}.
\end{proof}

It follows from \cref{prop.tri_dir_cartesian} and the fact that $\otimes$ is a monoidal product that for any $u\in\poly$ the maps
\[
	\ol{\Phi}_u(p)(q)\coloneqq u\otimes p\tri q
	\qqand
	\Phi_u(p)(q)\coloneqq u\tri p\tri q
\]
defining the functors in \eqref{eqn.Phi} are functorial in $p\in\polycart$ and $q\in\poly$.

\begin{proposition}\label{prop.indep}
The identity functor $\poly\to\poly$ can be regarded as a lax monoidal functor
\begin{equation}\label{eqn.indep}
	\indep\colon (\poly,\yon,\tri)\to(\poly,\yon,\otimes),
\end{equation}
Moreover the laxators (lax coherence maps), which we denote with the same symbol
\[\indep\colon (p\otimes q)\to (p\tri q)\]
are cartesian for, and natural in, $p,q\in\poly$.
\end{proposition}
\begin{proof}
Suppose given polynomials $p,q\in\poly$ and a set $X\in\smset$; since $\indep$ is merely a lax monoidal structure atop the identity functor, the only data in it is in its laxator, which we define using \cref{rem.positions_and_directions} as follows.

On types, we send an index $(I,J)\in p(1)\times q(1)$ to $(I,J\_)\in p\tri q(\1)$, where $J_!\colon p[I]\to q(1)$ is constant $J$, sending each $i$ to $J\in q(1)$ Backwards on terms, we send $(i,j)\mapsto (i,j)$; indeed both \cref{eqn.comp_formula,eqn.dir_formula} have the same set of directions $\sum_{i\in p[I]}q[J]\cong p[I]\times q[J]$ when $J_!\coloneqq J$ is independent of $I$. Thus it is clear that $\indep$ is cartesian. We leave it to the reader to check the relevant axioms.
\end{proof}

\begin{proposition}\label{prop.duoidal}
There is a duoidality between $\otimes$ and $\tri$, i.e.\ for every $p_1,p_2,q_1,q_2\in\poly$ there is a cartesian map
\[
	(p_1\tri p_2)\otimes(q_1\tri q_2)\To{\duoid} (p_1\otimes q_1)\tri (p_2\otimes q_2)
\]
satisfying the usual properties.
\end{proposition}
\begin{proof}
On types we begin with $(I_1, I_2),(J_1, J_2)\in ((p_1\tri p_2)\otimes(q_1\tri q_2))(1)$, where $I_2\colon I_1\to p_2(1)$ and $J_2\colon J_1\to q_2(1)$. It is sent by $\duoid_1$ to $(I_1,J_1),(I_2',J_2')\in (p_1\otimes q_1)\tri (p_2\otimes q_2)(1)$ where $I_2'\colon I_1\times J_1\to p_2(1)$ is given by first projecting onto $I_1$ and then applying $I_2$, and similarly $J_2'\colon I_1\times J_1\to q_2(1)$ is given by first projecting onto $J_1$ and then applying $J_2$. 

Backwards on terms, we begin with $((i_1,j_1),(i_2,j_2))\in (p_1\otimes q_1)\tri (p_2\otimes q_2)[(I_1,J_1),(I_2',J_2')]$, where $i_2\in I'_2(i_1,j_1)=I_2 i_1$ and $j_2\in J'_2(i_1,j_1)=J_2 j_2$. It is sent by the isomorphism $\duoid^\sharp_{(I_1, I_2),(J_1, J_2)}$ to $((i_1,i_2),(j_1,j_2))\in ((p_1\tri p_2)\otimes(q_1\tri q_2))[(I_1, I_2),(J_1, J_2)]$. We leave it to the reader to check the relevant axioms.
\end{proof}

We record a lemma that will be useful later; the proof is straightforward.

\begin{lemma}\label{lemma.duoid_indep}
For any polynomials $v,p,p'\in\poly$ the following diagram commutes:
\[
\begin{tikzcd}[column sep=0]
	&v\otimes p\tri p'\ar[dl, "\duoid"']\ar[dr, "\indep_{v,p\tri p'}"]\\
	(v\otimes p)\tri p'\ar[rr, "\indep_{v,p}\tri p'"']&&v\tri p\tri p'
\end{tikzcd}
\]
\end{lemma}

\begin{proposition}[$\kappa$-list monads]\label{prop.list_monad}
For any sum-product set $\kappa$, there is a cartesian monad structure $(\1,\Sigma)$ on the $\kappa$-list polynomial $u_\kappa\in\polycart$.
\end{proposition}
\begin{proof}
Recall that $u_\kappa=\sum_{N\in C_\kappa}\yon^N$, where $C_\kappa$ is a choice of one set for every cardinality $N<\kappa$, and that whenever $A<\kappa$ and $B_a<\kappa$ for each set in $(B_a)_{a\in A}$, the set $S(A,B)$ isomorphic to their disjoint union also satisfies $S(A,B)<\kappa$. 

The monoidal unit on $u_\kappa$ corresponds to the ordinal $\1<\kappa$, considered as a (cartesian) map $\yon\to u_\kappa$. The monoidal product $u_\kappa\tri u_\kappa\to u_\kappa$ sends $A\in u_\kappa(1)$ and $B\colon u_\kappa[A]\to u_\kappa(1)$ to $S(A,B)$. The monad laws are satisfied because coproduct is monoidal product and $u_\kappa$ has exactly one position (element in $C_\kappa$) for each cardinality $N<\kappa$. 
\end{proof}

\begin{definition}[$\kappa$-list monads]
For any sum-product set $\kappa$, we refer to the monad $(u_\kappa,\1,\Sigma)$ from \cref{prop.list_monad} as the \emph{$\kappa$-list monad}. Note that lax monoidal functors, such as $\indep$ from \eqref{eqn.indep}, send monoids to monoids. Hence, we also have a monoid structure 
\begin{equation}\label{eqn.otimes_monoid}
	\yon\To{\1} u
	\qqand
	u\otimes u\To{\indep} u\tri u\To{\Sigma}u.
\end{equation}
We denote it simply using parens: $(-,-)\colon u\otimes u\to u$.
\end{definition}

Our goal in the next section is to show that for any $\kappa$ as in \cref{ex.sum_prod_set}, the $\kappa$-list monad $(u_\kappa,\1,\Sigma)$ from \cref{prop.list_monad} is a universe in the sense of \cref{def.universe}.

%-------- Chapter --------%
\chapter{List monads are polynomial universes}

In this section, we will construct the lax monoidal functors and transformation
\[
\begin{tikzcd}[column sep=60pt]
	\Big(\polycart,\yon,\tri\Big)
		\ar[r, bend left=15pt,  start anchor={north east}, end anchor={north west}, "\ol{\Phi}_u", ""' name=P]
		\ar[r, bend right=15pt, start anchor={south east}, end anchor={south west}, "\Phi_u"', "" name=PP]&
	\Big(\en(\poly),\id,\circ\Big)
	\ar[from=P, to=P|-PP, Rightarrow, shorten=2mm, "\indep"]
\end{tikzcd}
\]
as we saw in \eqref{eqn.Phi}. The domain is the category $\polycart$ of polynomials and cartesian maps between them, and the codomain is $\en(\poly)$, the category of functors $\poly\to\poly$. As in \cref{eqn.olphi_phi} the functors will be given by 
\[
\ol{\Phi}_u(p)(q)\coloneqq u\otimes p\tri q
\qqand
\Phi_u(p)(q)\coloneqq u\tri p\tri q
\]
The functors and transformation being monoidal with respect to $(\yon,\tri)$ means that there are maps and diagrams
\begin{equation}\label{eqn.main_requirement_for_lax}
\begin{tikzcd}
	q\ar[r]\ar[d, equal]&u\otimes q\ar[d]\\
  q\ar[r]&u\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}
  u\otimes p_1\tri(u\otimes p_2\tri q)\ar[r]\ar[d]&
  u\otimes p_1\tri p_2\tri q\ar[d]\\
  u\tri p_1\tri u\tri p_2\tri q\ar[r]&
  u\tri p_1\tri p_2\tri q  
\end{tikzcd}
\end{equation}

natural in $p_1,p_2,q$, satisfying the appropriate commutative diagrams.
What we need to understand is the lax monoidality of $\ol{\Phi}_u$ and $\Phi_u$; these are what constrain $u$.

%---- Section ----%
\section{The switching transformation}

\cref{def.switching} is the technical center of the paper, defining the switching map; the idea is that a universe $u$ should be able to absorb arbitrary dependencies into it. In \cref{lemma.key} we will capture the formal consequences of the switching map. The remainder of the paper will be shuffling and unpacking these formal consequences. 

The unexpected thing about this map is that to define it requires we use what we call \emph{overflow}. It says that if you try to multiply too many things together, and the result is not a type in $u$, then define the result to be the empty type. One could instead restrict the domain (the sort of $p$ one is allowed to use), but then the statement becomes less attractive. We also think it is an interesting feature to include overflow values.

\begin{definition}[Switching transformation $\ol{\switch}$]\label{def.switching}
Let $u\coloneqq u_\kappa$ be a $\kappa$-list polynomial. Then for any $p\in\poly$ we define the \emph{$p$-switching transformation}
\[\ol{\switch}_{p}\colon p\tri(u\otimes -)\to u\otimes p\tri -\]
as follows.

Fix $q\in\polycart$. To give the $q$-component $\ol{\switch}\coloneqq\ol{\switch}_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q$ of the $p$-switching transformation, we follow \cref{rem.positions_and_directions}. We first define the function $\ol{\switch}_1$  on types. A type in the family $p\tri(u\otimes q)\to u\otimes p\tri q$ consists of a triple $(I,A,J)$ where $I\in p(1)$, $A\colon p[I]\to u(1)$, and $J\colon p[I]\to q(1)$. We want to define a type in the family $u\otimes p\tri q$, which consists of a triple $(A',I',J')$ where $A'\in u(1)$, $I'\in p(1)$, and $J'\colon p[I']\to q(1)$. We define $I'\coloneqq I$, $J'\coloneqq J$, and $A'$ as follows:
\begin{equation}\label{eqn.overflow}
  A'\coloneqq
  \begin{cases}
  	\Pi(p[I],A)&\tn{ if }\Pi(p[I],A)<\kappa\\
		0&\tn{ otherwise}
  \end{cases}
\end{equation}
In a case of $(I,A,J)$ for which the second condition is activated, we say that $\ol{\switch}$ \emph{overflows}; otherwise we say it \emph{succeeds}.

For the function $\ol{\switch}^\sharp_{(I,A,J)}\colon (u\otimes p\tri q)[(A',I,J)]\to(p\tri(u\otimes q))[(I,A,J)]$ backwards on terms, there are two cases. If $A'=0$ then $(u\otimes p\tri q)[(A',I,J)=0$, so there is a unique map; in this sense one could say ``overflow causes the system to halt''. Otherwise, we need a map
\begin{equation}\label{eqn.not_injective}
\prod_{i\in p[I]}A i\times\sum_{i\in p[I]}q[J i]\to\sum_{i\in p[I]}(A i)\times (J i)
\end{equation}
and it is given by $(a,i,j)\mapsto(i,a i,j i)$.%
\footnote{Note that the map $\ol{\switch}^\sharp_{(I,A,J)}$ is not generally injective, because for a given input $(a,i,j)$, most of the data in $a$ is discarded; hence $\ol{\switch}$ is not cartesian. This has nothing to do with overflow, and hence could not be avoided by merely restricting $\polycart$ to $\kappa$-bounded polynomials.}
\end{definition}

One can avoid the whole ``overflow'' issue by restricting the domain category throughout this paper to $\polycart_{<\kappa}\ss\polycart$, meaning that the switching map $\switch_p\colon p\tri u\to u\otimes p$ would be restricted only to those $p$ whose exponents have cardinality bounded by $\kappa$. We contemplated this move, but decided to allow arbitrary $p$ in order to imagine dependencies on ``real world'', or ``external'' parameters.

\begin{definition}[Switching map $\switch$]\label{def.switchmap}
Let $u\coloneqq u_\kappa$ be a $\kappa$-list polynomial. Then for any $p\in\poly$ we define the \emph{switching map} denoted $\switch_p\colon p\tri u\to u\tri p$ to be the composite
\[p\tri u\To{\ol{\pi}_\yon}u\otimes p\To{\indep}u\tri p\]
of $\indep$ with the $\yon$-component of the switching transformation $\pi_p\coloneqq\indep\circ\ol{\pi}_\yon$.
\end{definition}

%---- Section ----%
\section{Main theorem}

In this section we prove the main theorem of the paper, which says that $\kappa$-list monads are polynomial universes. But to get there requires what we call the ``key lemma'' (\cref{lemma.key}), which lays out all the diagrams that actually get the job done.%
\footnote{We wouldn't be surprised if sometime in the future the diagrams in \cref{lemma.key} are found to assemble into a more compact or elegant structure than the natural transformation diagram \eqref{eqn.Phi} defining universe polynomials. For now, that is the most elegant packaging of these diagrams that we know of.}
To prove it we will need the---so far unused---property of $\kappa$ that it is closed under its own products, i.e.\ that for any $A<\kappa$ and $(B_a)_{a\in A}$ with each $B_a<\kappa$, the product $\prod_{a\in A}B_a=\Pi(A,B)<\kappa$ is too.


\begin{lemma}[Key lemma]\label{lemma.key}
Let $u\coloneqq u_\kappa$ be the $\kappa$-list polynomial for a sum-product set $\kappa$, let $\ol{\switch}$ and $\pi$ be as in Definitions~\ref{def.switching}~and~\ref{def.switchmap}. Then $\ol{\switch}$ and $\switch$ are natural and the following diagrams commute:
\begin{gather}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&u\ar[dl, equal]\ar[dr, equal]\\
	\yon\tri u\ar[rr, "\switch_{\yon}"']\&\&u\otimes\yon
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&p\ar[dl, "p\tri\1"']\ar[dr,"\1\tri p"]\\
	p\tri u\ar[rr, "\switch_{p}"']\&\&u\tri p
\end{tikzcd}\label{eqn.key_smalls}
\\[15pt]
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri(u\otimes q)\ar[r, "\ol{\switch}_{p,q}"]\ar[d, "\indep"']\&
	u\otimes p\tri q\ar[d, "\duoid"]\\
	p\tri u\tri q\ar[r, "\ol\switch_{p,\yon}\tri q"']\&
	(u\otimes p)\tri q
\end{tikzcd}\label{eqn.key_compare}
\\[15pt]
\begin{tikzcd}[column sep=-10pt, ampersand replacement=\&]
	\&p\tri p'\tri (u\otimes q)\ar[dl, "p\tri\ol\switch_{p',q}"']\ar[dr,"\ol\switch_{p\tri p',q}"]\\
	p\tri (u\otimes p'\tri q)\ar[rr, "\ol\switch_{p, p'\tri q}"']\&\&u\otimes p\tri p'\tri q
\end{tikzcd}\label{eqn.key_med3}
\\[15pt]
\begin{tikzcd}[column sep=0pt, ampersand replacement=\&]
	\&p\tri p'\tri u\ar[dl, "p\tri\switch_{p'}"']\ar[dr,"\switch_{p\tri p'}"]\\
	p\tri u\tri p'\ar[rr, "\switch_{p}\tri p'"']\&\&u\tri p\tri p'
\end{tikzcd}\label{eqn.key_med1}
\\[15pt]
\begin{tikzcd}[ampersand replacement=\&, column sep=large]
  p\tri u\tri u\ar[d, "p\tri\Sigma"']\ar[r, "\switch_p\tri u"]\&
  u\tri p\tri u\ar[r, "u\tri\switch_p"]\&
  u\tri u\tri p\ar[d, "\Sigma\tri p"]\\
  p\tri u\ar[rr, "\switch_p"']\&\&
  u\tri p
\end{tikzcd}\label{eqn.key_large}
\\[15pt]
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri (u\otimes u)\ar[r, "\ol{\switch}_{p,u}"]\ar[d, "p\tri{(-,-)}"']\&
	u\otimes p\tri u\ar[r, "u\otimes\ol\switch_{p,\yon}"]
	\&u\otimes u\otimes p\ar[d, "{(-,-)}\otimes p"]\\
	p\tri u\ar[rr, "\ol\switch_{p,\yon}"']
	\&\&
	u\otimes p
\end{tikzcd}\label{eqn.key_med2}
\end{gather}
\end{lemma}
\begin{proof}
We begin with naturality. Clearly $\ol{\switch}_p$ is natural in $q\in\poly$. Though the map $\ol{\switch}_{p}$ would not be natural for arbitrary polynomial maps $\alpha\colon p\to p'$,%
\footnote{
Consider the unique map $\alpha\colon\yon^1\to \yon^0$. The naturality diagram
\[
\begin{tikzcd}[ampersand replacement=\&]
  \yon^1\tri u\ar[r, "\switch_{\yon^1}"]\ar[d, "\alpha\tri u"']\&
  u\otimes\yon^1\ar[d, "u\otimes\alpha"]\\
  \yon^0\tri u\ar[r, "\switch_{\yon^0}"']\&
  u\otimes \yon^0
\end{tikzcd}
\]
does not commute: starting with $\1\vdash A$, the top composite yields $(A,())$, whereas the bottom composite yields $(0,())$. Thus $\switch$, and hence $\ol{\switch}$ is not generally natural for noncartesian $\alpha$.
}
it is natural when $\alpha$ is cartesian. Indeed if $\alpha_1(I)=I'$ then the bijection $\alpha_I^\sharp$ extends to a bijection
\[\Pi(p[I],A)\cong\Pi(p'[I'],A)\]
and $\ol{\switch}_p$ overflows iff $\ol{\switch}_{p'}$ does. Since $\switch$ is the $\yon$-component of $\ol{\switch}$ composed with $\indep$, it is natural in $p$ as well.

We next consider the commutativity of the diagrams in \eqref{eqn.key_smalls}. The map $\yon\tri u\to u\otimes\yon$ sends $(\1,A)\mapsto\prod_{():\1}A()$, which is isomorphic to $A$ (and hence equal in $C_\kappa$). Thus the left hand triangle commutes. For the right-hand triangle, suppose given $I\in p(1)$. Under the left-hand composite map it is sent to $(\Pi(p[I],\1),I)$ and under the right-hand map it is sent to $(\1,I)$; these are the same element of $C_\kappa$, since $\Pi(p[I],\1)$ is defined isomorphic to a product of $\1$'s, which is isomorphic to $\1$. The maps on directions are also identical.

To prove that \eqref{eqn.key_compare} commutes, suppose given $(I,A,J)\in p\tri(u\otimes q)(1)$, i.e.\ $A\colon p[I]\to u(1)$ and $J\colon p[I]\to q(1)$. Around both composites it is sent to $((\Pi(I,A),I),J')\in (u\otimes p)\tri q$ where $J'$ is the composite $\Pi(I,A)\times I\to I\To{J} q(1)$.
% It may be helpful to see this one in slow motion: around the top we have
%\[I\vdash (A,J)\quad\mapsto\quad \Pi(I, A),(I\vdash J)\quad\mapsto\quad (\Pi(I,A),I)\vdash J\]
%and around the bottom we have
%\[
%I\vdash (A,J)\quad\mapsto\quad I\vdash A\vdash J\quad\mapsto\quad (\Pi(I, A),I)\vdash J
%\]

To prove that \eqref{eqn.key_med3} commutes, it suffices to show for any set $I$, sets $(I'_i)_{i\in I}$, and sets $(A_{i,i'})_{i\in I, i'\in I'_i}$ with $A_{i,i'}<\kappa$, that first there is a bijection
\[\Pi(\Sigma(I,I'),A)\cong\Pi(I,\Pi(I',A))\]
which there is, and that second the overflow handling agrees, as we now argue. If for any $i\in I$ there is an overflow in $\Pi(I'_i,A_i)$ then it will output $0$, and the product of anything with $0$ is $0$; hence the two sides agree that the result is $0$. Otherwise, if all $\Pi(I'_i,A_i)$ succeed, then if the mutual result is too big, both sides again agree that the result is $0$. The commutativity of \eqref{eqn.key_med1} follows from \eqref{eqn.key_compare}, \eqref{eqn.key_med3}, and \cref{lemma.duoid_indep}.

To prove that \eqref{eqn.key_large} commutes, suppose given $(I,A,B)\in p\tri(u\tri u)(1)$, where $A\colon p[I]\to u(1)$ and $B\colon\sum_{i:p[I]}Ai\to u(1)$. It is easy to check that, for some $A_1,A_2\in u(1)$, it is sent under the top composite map to  $(A_1,I)$ and under the bottom composite map it is sent to $(A_2,I)$. Assuming neither overflows, these are 
\[
  A_1\cong\Pi(p[I],\Sigma(A, B))
  \qqand
	A_2\cong\Sigma(\Pi(p[I],A),\Pi(p[I],B))
\] 
respectively, and these sets are isomorphic (hence equal in $C_\kappa$). So it remains to deal with the overflow situations.

Note that $\Pi(p[I],\Sigma(A, B))\cong\Sigma(\Pi(p[I],A),\Pi(p[I],B))$ are bijective sets, so one overflows iff the other does. If they overflow then $\Pi(p[I],A\times B)>\kappa$ is too big, so $A_1=0$. In this case we also know that either $\Pi(p[I],A)>\kappa$ or $\Pi(p[I],Ba)>\kappa$ is too big, for some $a\in\Pi(p[I],A)$, by assumption on $\kappa$ (see \cref{def.sum_prod_set}). In the first case we will have $A_2=\Sigma(0,\Pi(p[I],B))$ and in the second case we will have $A_2=\Pi(p[I],\Sigma(A, 0))$; either way, the result is $0$. Hence the diagram commutes. 

The commutativity of \eqref{eqn.key_med2} follows from \eqref{eqn.key_compare}, \eqref{eqn.key_large}, and \cref{lemma.duoid_indep}. This completes the proof.
\end{proof}


We now prove the main theorem.

\begin{theorem}\label{thm.main}
For any sum-product set $\kappa$, the $\kappa$-list monad is a polynomial universe. 
\end{theorem}
\begin{proof}
Let $\kappa$ be a sum-product set, $u\coloneqq u_\kappa$ the associated list polynomial, and $(\1,\Sigma)$ the list monad structure; see \cref{def.sum_prod_set,prop.list_monad}. By \cref{def.universe} we need to define the laxators for the two functors in the diagram 
\[
\begin{tikzcd}[column sep=60pt]
	\Big(\polycart,\yon,\tri\Big)
		\ar[r, bend left=15pt,  start anchor={north east}, end anchor={north west}, "q\mapsto u\otimes p\tri q", ""' name=P]
		\ar[r, bend right=15pt, start anchor={south east}, end anchor={south west}, "q\mapsto u\tri p\tri q"', "" name=PP]&
	\Big(\en(\poly),\id,\circ\Big)
	\ar[from=P, to=P|-PP, Rightarrow, shorten=2mm, "\indep"]
\end{tikzcd}
\]
labeled by where they send $p\in\polycart$, and prove that the transformation $\indep$ is monoidal. As mentioned in \eqref{eqn.main_requirement_for_lax}, we need horizontal maps
\[
\begin{tikzcd}
	q\ar[r, "\ol\phi_q"]\ar[d, equal]&u\otimes q\ar[d, "\indep"]\\
  q\ar[r, "\phi_q"']&u\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[column sep=large]
  u\otimes p_1\tri(u\otimes p_2\tri q)\ar[r, "\ol\phi_{p_1,p_2,q}"]\ar[d, "\indep\tri\indep"']&
  u\otimes p_1\tri p_2\tri q\ar[d, "\indep"]\\
  u\tri p_1\tri u\tri p_2\tri q\ar[r, "\phi_{p_1,p_2,q}"']&
  u\tri p_1\tri p_2\tri q  
\end{tikzcd}
\]
natural in $p_1,p_2\in\polycart$ and $q\in\poly$, that make those diagram commute. Define $\ol\phi_q$ and $\phi_q$ to respectively be the top and bottom maps in the square:
\[
\begin{tikzcd}
	q\ar[r, "\1\otimes q"]\ar[d, equal]&u\otimes q\ar[d, "\indep"]\\
  q\ar[r, "\1\tri q"']&u\tri q
\end{tikzcd}
\]
Define $\ol\phi_{p_1,p_2,q}$ and $\phi_{p_1,p_2,q}$ to be the top and bottom composites in the rectangle
\[
\begin{tikzcd}[column sep=50pt]
  u\otimes p_1\tri(u\otimes p_2\tri q)\ar[r, "u\otimes\ol\switch_{p_1,p_2\tri q}"]\ar[d, "\indep\tri\indep"']&
  u\otimes u\otimes p_1\tri p_2\tri q\ar[r, "{(-,-)}\tri p_1\tri p_2\tri q"]\ar[d]&[10pt]
  u\otimes p_1\tri p_2\tri q\ar[d, "\indep"]\\
  u\tri p_1\tri u\tri p_2\tri q\ar[r, "u\tri\switch_{p_1}\tri p_2\tri q"']&
  u\tri u\tri p_1\tri p_2\tri q\ar[r, "\Sigma\tri p_1\tri p_2\tri q"']&
  u\tri p_1\tri p_2\tri q  
\end{tikzcd}
\]
where we use $\ol{\switch}$ and $\switch$ (see Definitions~\ref{def.switching}~and~\ref{def.switchmap}) and the multiplications $(-,-)$ and $\otimes$.
The left-hand square in this diagram commutes by \eqref{eqn.key_compare} and the right-hand square commutes by \eqref{eqn.otimes_monoid} and the naturality of $\indep$.

It remains to show that in both cases these satisfy the three commutative diagrams of a lax monoidal functor. The unit diagrams are:
\begin{gather*}
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\otimes p\tri q\ar[r, "\ol\phi_{u\otimes p\tri q}"]\ar[dr, bend right=20pt, equal]\&
	u\otimes u\otimes p\tri q \ar[d, "\ol\phi_{\yon,p,q}"]\\
	\&
	u\otimes p\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\otimes p\tri q\ar[r, "u\otimes p\tri\ol\phi_q"]\ar[dr, bend right=20pt, equal]\&
	u\otimes p\tri (u\otimes q)\ar[d, "\ol\phi_{p,\yon,q}"]\\
	\&
	u\tri p\tri q
\end{tikzcd}
\\[15pt]
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\tri p\tri q\ar[r, "\phi_{u\tri p\tri q}"]\ar[dr, bend right=20pt, equal]\&
	u\tri u\tri p\tri q \ar[d, "\phi_{\yon,p,q}"]\\
	\&
	u\tri p\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\tri p\tri q\ar[r, "u\tri p\tri\phi_q"]\ar[dr, bend right=20pt, equal]\&
	u\tri p\tri u\tri q\ar[d, "\phi_{p,\yon,q}"]\\
	\&
	u\tri p\tri q
\end{tikzcd}
\end{gather*}
Both the top and bottom diagrams commute by the respective monad unit laws and the commutativity of the respective triangles in \eqref{eqn.key_smalls}.

We conclude by showing that the associativity diagrams for $\ol\Phi$ and $\Phi$:
\begin{gather*}
\begin{tikzcd}[ampersand replacement=\&, column sep=60pt]
	u\otimes p_1\tri(u\otimes p_2\tri(u\otimes p_3\tri q))
		\ar[r, "u\otimes p_1\tri\ol\phi_{p_2,p_3,q}"]
		\ar[d, "\ol\phi_{p_1,p_2,u\otimes p_3\tri q}"']\&
	u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)
		\ar[d, "\ol\phi_{p_1,p_2\tri p_3,q}"]\\
	u\otimes p_1\tri p_2\tri(u\otimes p_3\tri q)
		\ar[r, "\ol\phi_{p_1\tri p_2,p_3,q}"']\&
	u\otimes p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\\[15pt]
\begin{tikzcd}[ampersand replacement=\&, column sep=60pt]
	u\tri p_1\tri u\tri p_2\tri u\tri p_3\tri q
		\ar[r, "u\tri p_1\tri\phi_{p_2,p_3,q}"]
		\ar[d, "\phi_{p_1,p_2,u\tri p_3\tri q}"']\&
	u\tri p_1\tri u\tri p_2\tri p_3\tri q
		\ar[d, "\phi_{p_1,p_2\tri p_3,q}"]\\
	u\tri p_1\tri p_2\tri u\tri p_3\tri q
		\ar[r, "\phi_{p_1\tri p_2,p_3,q}"']\&
	u\tri p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\end{gather*}
commute for any $q\in\poly$. Unpacking the first, we obtain the following diagram, where the four sides above agree with the four composite sides shown:%
\footnote{We label the maps merely by ``hints'' for space reasons; e.g. the top maps labeled $\switch$ and $\Sigma$ are fully written as $u\tri p_1\tri u\tri p_2\tri\switch_{p_2}\tri p_3\tri q$ and $u\tri p_1\tri\Sigma\tri p_2\tri p_3\tri q$.}
\[\fontsize{9.6pt}{9.6pt}\selectfont
\begin{tikzcd}
	u\otimes p_1\tri(u\otimes p_2\tri(u\otimes p_3\tri q))\ar[r, "\ol{\pi}"]\ar[dd, "\ol{\pi}"']&
	u\otimes p_1\tri(u\otimes u\otimes p_2\tri p_3\tri q)\ar[r, "{(-,-)}"]\ar[d, "\ol{\pi}"]&[5pt]
	u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)\ar[dd, "\ol{\pi}"]\\&
	u\otimes u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)\ar[dd, "\ol{\pi}"]\\[-12pt]
	u\otimes u\otimes p_1\tri p_2\tri(u\otimes p_3\tri q)\ar[dd, "{(-,-)}"']\ar[ur, bend left=5pt, start anchor={north east}, "\ol{\pi}"]\ar[dr, bend right=5pt, start anchor={south east}, "\ol{\pi}_{p_1\tri p_2}"']&&
	u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[dd, "{(-,-)}"]\\[-12pt]&
	u\otimes u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[d, "{(-,-)}\otimes u"]\ar[ur, bend right=5pt, start anchor={east}, end anchor={south west}, "u\otimes{(-,-)}"']\\
	u\otimes(p_1\tri p_2\tri(u\otimes p_3\tri q))\ar[r, "\ol{\pi}_{p_1\tri p_2}"']&
	u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[r, "{(-,-)}"']&
	u\otimes p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]
The top-left and bottom-left squares commute by functoriality of monoidal products, and the bottom right square commutes by the monad associativity law. The rest is \cref{lemma.key}: the little triangle commutes by \eqref{eqn.key_med3} and the pentagon commutes by \eqref{eqn.key_med2}.

The proof of the associativity for $\Phi$ is quite similar. Unpacking the second, we obtain the following diagram, where the four sides above agree with the four composite sides shown:%
\[%\fontsize{11pt}{11pt}\selectfont
\begin{tikzcd}
	u\tri p_1\tri u\tri p_2\tri u\tri p_3\tri q\ar[r, "\switch"]\ar[dd, "\switch"']&
	u\tri p_1\tri u\tri u\tri p_2\tri p_3\tri q\ar[r, "\Sigma"]\ar[d, "\switch"]&
	u\tri p_1\tri u\tri p_2\tri p_3\tri q\ar[dd, "\switch"]\\&
	u\tri u\tri p_1\tri u\tri p_2\tri p_3\tri q\ar[dd, "\switch"]\\[-12pt]
	u\tri u\tri p_1\tri p_2\tri u\tri p_3\tri q\ar[dd, "\Sigma"']\ar[ur, bend left=5pt, start anchor={north east}, "\switch"]\ar[dr, bend right=5pt, start anchor={south east}, "\switch_{p_1\tri p_2}"']&&
	u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[dd, "\Sigma"]\\[-12pt]&
	u\tri u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[d, "\Sigma\tri u"]\ar[ur, bend right=5pt, start anchor={east}, end anchor={south west}, "u\tri\Sigma"']\\
	u\tri p_1\tri p_2\tri u\tri p_3\tri q\ar[r, "\switch_{p_1\tri p_2}"']&
	u\tri u\tri p_1\tri p_2\tri p_3\tri q\ar[r, "\Sigma"]&
	u\tri p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]




The top-left and bottom-left squares commute by functoriality of monoidal products, and the bottom right square commutes by the monad associativity law. The rest is \cref{lemma.key}: the little triangle commutes by \eqref{eqn.key_med1} and the pentagon commutes by \eqref{eqn.key_large}.
\end{proof}


%-------- Chapter --------%
\chapter{Consequences in the language of dependent types}

The main theorem really just packages the story. The real heart of the matter---at least for dependent types---is \cref{lemma.key} applied to some  polynomial universe $(u,\1,\Sigma)$, which we fix for the rest of this section.

%---- Section ----%
\section{Notation}

Our notation is not meant to be authoritative; the mathematics of polynomial functors takes care of the meaning, so that we can be more relaxed about how we want to represent it. The following is only meant to have the level of formality of a math paper, not of a logic or philosophy paper.

\paragraph{Type collections, types, terms, and dependencies.}
We refer to a polynomial $p\in\polycart$ as a \emph{type collection}. We refer to each element $I\in p(1)$ as a \emph{type}, and we refer to each element $i\in p[I]$ as a \emph{term of type $I$} and write $i:p[I]$.

We refer to $u$ as the \emph{type universe}; it is a type collection, but has more structure. Let $\U\coloneqq u(1)$ be the positions of the universe polynomial $u$. We denote each element of $\U$ using an upper-case letter, $A,B$, etc., and call it a \emph{base type}. Given a base type $A\in u(1)$, we denote $u[A]$ simply by $[A]$, since $u$ is fixed. We denote each element of $[A]$ using the same letter in lower-case, $a,a':[A]$, etc.; these are terms of type $A$.

We refer to $\yon$ as the \emph{unit} type collection. There is exactly one element of $\yon(1)$; we denote it $\1$. The set $\yon[\1]$ has a unique element, and we denote it $()$.

An element of $p\tri q(1)=(p\tri q)(1)$ consists of an element $I:p(1)$ and an element $J i:q(1)$ for every $i:p[I]$; we denote it by $(I\vdash J)\in (p\tri q)(1)$. Since $r\coloneqq p\tri q$ is a polynomial, $I\vdash J$ is just a type (an element of $r(1)$); however if we receive $r$ as a composite of $p$ and $q$ we may refer to $I\vdash J$ as a \emph{dependent type}: the $q$-type depends on a term of the $p$-type. A term of type $I\vdash J$ consists of a pair $(i,j)$ where $i:p[I]$ and $j: q[J i]$; we denote it $(i,j):(p\tri q)[I\vdash J]$.

Every time a type depends on terms of a previous type, we use a turnstyle $\vdash$; thus there may be several turnstyles in a type definition. Our notation simply follows the polynomial formalism in the sense that whenever we see $\tri$ in the polynomials, we see $\vdash$ in the types. For example, a type in $p\tri q\tri r$ would be denoted $I\vdash J\vdash K$. Here we have for each $i\in p[I]$ a $q$-type $Ji\in q(1)$ and for each $j\in q[J i]$ an $r$-type $Kij\in r(1)$. A term in $I\vdash J\vdash K$ is a triple $(i,j,k)$ where $i\in p[I]$, $j\in q[Ji]$, and $k\in r[Kij]$.

An element of $(p\otimes q)(1)$ consists of a pair $(I,J)\in p(1)\times q(1)$; we call it a \emph{product type}. An element of $(p\otimes q)[(I,J)]$ consists of a pair $(i,j)\in p[I]\times q[J]$. 

\paragraph{Monoid structures on base types.}

The cartesian monoid structures $(u,\1,\Sigma)$ and $(u,\1,(-,-))$, and the map $\indep\colon u\otimes u\to u\tri u$, are denoted as follows. The map $\1\colon\yon\to u$ provides a certain base type, which we again call $\1\in U$. The map $\Sigma\colon u\tri u\to u$ provides a function $u\tri\U\to\U$, which we again call $\Sigma$. Thus for any dependent type $A\vdash B:u\tri\U$, we can form $\Sigma(A,B):\U$. Similarly the map $(-,-)\colon u\otimes u\to u$ provides a function $\U\times \U\to\U$, which we again denote $(-,-)$. Thus for any pair of types $(A,B):\U\times \U$ we can form $(A,B):\U$. 
\[
  \begin{prooftree}
    \Infer0{\1}
  \end{prooftree}
  \hspace{.6in} 
  \begin{prooftree}
    \Hypo{A, B}
    \Infer1{(A,B)}
  \end{prooftree}
\hspace{.6in}
  \begin{prooftree}
    \Hypo{A\vdash B}
    \Infer1{\Sigma(A,B)}
  \end{prooftree}
\]
Its cartesianness means that $\1$ has a single term, which we again call $():[\1]$. The cartesianness of $\Sigma$ means that a term of $\Sigma(A,B)$ consists of an element of $u\tri u[(A\vdash B)]$, i.e.\ a term $a:[A]$ and a term $b:[Ba]$. Similarly, a term of $(A,B)$ consists of an element $(a,b):[A]\times[B]$. From the third one, we can also write
\begin{equation}\label{eqn.dep_vs_sigma}
\begin{prooftree}
  \Infer0{(A\vdash B)\equiv \Sigma(A,B)}
\end{prooftree}
\end{equation}
which means that choosing a term of $A\vdash B$, meaning an $a:[A]$ and a $b:[B a]$, is the same thing as choosing a term of $\Sigma(A,B)$. The analogous statements for the first two say that the empty context has one element, and that choosing a term of $A,B$, meaning an $a:[A]$ and a $b:[B]$, is the same thing as choosing a term of $(A,B)$.


\paragraph{The switching transformation.}

Recall that for any $p\in\polycart$ and $q\in\poly$, \cref{def.switching} provides a morphism%
\footnote{As usual, $\tri$ binds the tightest, so $\U\times u\tri \U$ denotes $\U\times(u\tri \U)$.}
\[\switch_{p,q}\colon p\tri (u\otimes q)\to u\otimes p\tri q\]
Thus, given a dependent type $I\in p(1)$, a base type $A_i:\U$ and a type $J i\in q(1)$ for each $i\in p[I]$, we obtain a type denoted $(I\to A):\U$ (and we keep $I,J$ as before). In symbols,
\begin{equation*}
  \begin{prooftree}
    \Hypo{I\vdash (A, J)}
    \Infer1{I\to A, I\vdash J}
  \end{prooftree}
\end{equation*}
Given terms $a:[I\to A]$, $i:p[I]$, and $j:q[Ji]$, we obtain a term $(i,a i, j):p\tri(u\otimes q)[I\vdash (A,J)]$. Unlike the case for $\1$, $\Sigma$, and $(-,-)$, this construction is not a bijection because $\switch_{u,u}$ is not cartesian, as explained in the footnote below \cref{eqn.not_injective}.

\begin{remark}\label{rem.switching_later_coords_irrel}
The switching map acts on a dependent type $I\vdash A$ by modifying $A$, even as $I$ moves past unmodified: the result is $(I\to A, I)$. Thus when there are equations between various applications of the switching map, the later coordinates are generally not interesting; they just say something like $I=I$.

However, there is something interesting about terms: there is a map from terms of $(I\to A,I)$ back to terms of $I\vdash A$, namely $(a,i)\mapsto(i,ai)$.
\end{remark}

%---- Section ----%
\section{Unpacking the results}


Before we start, note that we already have the pairing laws from the fact that $(-,-)$ and $\Sigma$ are cartesian monads.
%\[
%\begin{array}{cc}
%	(A,\1)=A=(\1,A)&(A,(B,C))=((A,B),C)\\
%	\Sigma(A,\1)=A=\Sigma(\1,A)&
%		\Sigma(A,\Sigma(B,C))=\Sigma(\Sigma(A,B),C)
%\end{array}
%\]
\begin{gather*}
\begin{prooftree}
	\Hypo{A:\U}
	\Infer1{(A,\1)\equiv A\equiv (\1,A)}
\end{prooftree}
\hspace{.6in}
\begin{prooftree}
	\Hypo{A:\U}
	\Hypo{B:\U}
	\Hypo{C:\U}
	\Infer3{(A,(B,C))\equiv ((A,B),C)}
\end{prooftree}
\\[10pt]
\begin{prooftree}
	\Hypo{A:\U}
	\Infer1{\Sigma(A,\1)\equiv A\equiv \Sigma(\1,A)}
\end{prooftree}
\hspace{.6in}
\begin{prooftree}
	\Hypo{A:\U}
	\Hypo{B:\U}
	\Hypo{C:\U}
	\Infer3{\Sigma(A,\Sigma(B,C))\equiv \Sigma(\Sigma(A,B),C)}
\end{prooftree}
\end{gather*}
These also come with term conversions. The second pair looks exactly like the first pair, because of our notation, so we don't rewrite it:
\begin{gather*}
\begin{prooftree}
	\Hypo{a:[A]}
	\Infer1{(a,())\equiv a\equiv ((),a)}
\end{prooftree}
\hspace{.6in}
\begin{prooftree}
	\Hypo{a:[A]}
	\Hypo{b:[B]}
	\Hypo{c:[C]}
	\Infer3{(a,(b,c))\equiv ((a,b),c)}
\end{prooftree}
\end{gather*}

We now unpack the results from \cref{lemma.key}. The diagrams
\[
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&u\ar[dl, equal]\ar[dr, equal]\\
	\yon\tri u\ar[rr, "\switch_{\yon}"']\&\&u\otimes\yon
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[column sep=10pt, ampersand replacement=\&]
	\&p\ar[dl, "p\tri\1"']\ar[dr,"\1\tri p"]\\
	p\tri u\ar[rr, "\switch_{p}"']\&\&u\tri p
\end{tikzcd}
\]
in \eqref{eqn.key_smalls} are translated as:
\[
  \begin{prooftree}
    \Hypo{A : \U}
    \Infer1{(\1\to A)\equiv A:p\tri p'\tri\U}
  \end{prooftree}
  \hspace{.6in}
  \begin{prooftree}
    \Hypo{I : p(1)}
    \Infer1{(I\to \1)\equiv \1}
  \end{prooftree}
\]
In fact, they also imply
\[
  \begin{prooftree}
    \Hypo{A : \U}
    \Infer1{\1\equiv\1}
  \end{prooftree}
  \hspace{.6in}
  \begin{prooftree}
    \Hypo{I : p(1)}
    \Infer1{I\equiv I}
  \end{prooftree}
\]
in the second coordinates, as predicted by \cref{rem.switching_later_coords_irrel}; in the following we will leave off the later coordinates when they are similarly too obvious to be interesting.

The rule provided by the next diagram \eqref{eqn.key_compare} is already inherent in the way our notation works (much like how, in string diagrams, associativity is there but invisible). In the next diagram \eqref{eqn.key_med3}
\[
\begin{tikzcd}[column sep=-10pt, ampersand replacement=\&]
	\&p\tri p'\tri (u\otimes q)\ar[dl, "p\tri\ol\switch_{p',q}"']\ar[dr,"\ol\switch_{p\tri p',q}"]\\
	p\tri (u\otimes p'\tri q)\ar[rr, "\ol\switch_{p, p'\tri q}"']\&\&u\otimes p\tri p'\tri q
\end{tikzcd}
\]
we translate tersely as left, or verbosely as right; see \cref{rem.switching_later_coords_irrel}:%
\footnote{
This syntax, which includes a turnstyle in the domain of an arrow $(I\vdash I')\to A$, is unusual. But we can understand it in more classical notation below, either in its native form as to the left, or using \cref{eqn.dep_vs_sigma} which gives the equivalent form on the right:
\[
  \prod_{i:I,\; i':I' i}A i i'\;
  \equiv\;
  \prod_{i:I}\prod_{i':I' i}A i i'
  \equiv\;
  \prod_{(i,i'):\sum_{i:I}I' i}A (i,i')\;
\]
}
\[
  \begin{prooftree}
    \Hypo{I\vdash I'\vdash A}
    \Infer1{((I\vdash I')\to A)\equiv (I\to I'\to A)}
  \end{prooftree}
\hspace{.6in}
  \begin{prooftree}
    \Hypo{I\vdash I'\vdash (A,J)}
    \Infer1{((I\vdash I')\to A,I\vdash I'\vdash J)\equiv (I\to I'\to A, I\vdash I'\vdash J)}
  \end{prooftree}
\]
From the verbose version we also get a derivation rule backwards on terms, but not conversions (since the switching map is not cartesian).
\[
  \begin{prooftree}
    \Hypo{a,i,i',j}
    \Infer1{i,i',(a i i', j)}
  \end{prooftree}
\]

Next we have diagram \eqref{eqn.key_med1} 
\[
\begin{tikzcd}[column sep=0pt, ampersand replacement=\&]
	\&p\tri p'\tri u\ar[dl, "p\tri\switch_{p'}"']\ar[dr,"\switch_{p\tri p'}"]\\
	p\tri u\tri p'\ar[rr, "\switch_{p}\tri p'"']\&\&u\tri p\tri p'
\end{tikzcd}
\]
which was derived from \cref{eqn.key_compare}, and perhaps unsurprisingly has the very similar content. The terse version (left) is the same as above, and the verbose version (right) is slightly different:
\[
  \begin{prooftree}
    \Hypo{I\vdash I'\vdash A}
    \Infer1{((I\vdash I')\to A)\equiv (I\to I'\to A)}
  \end{prooftree}
\hspace{.6in}
  \begin{prooftree}
    \Hypo{I\vdash I'\vdash A}
    \Infer1{((I\vdash I')\to A\vdash I\vdash I')\equiv (I\to I'\to A\vdash I\vdash I')}
  \end{prooftree}
\]
From the verbose version we also get a derivation rule backwards on terms:
\[
  \begin{prooftree}
    \Hypo{a,i,i'}
    \Infer1{i,i',a i i'}
  \end{prooftree}
\]
The next diagram \eqref{eqn.key_large}
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=large]
  p\tri u\tri u\ar[d, "p\tri\Sigma"']\ar[r, "\switch_p\tri u"]\&
  u\tri p\tri u\ar[r, "u\tri\switch_p"]\&
  u\tri u\tri p\ar[d, "\Sigma\tri p"]\\
  p\tri u\ar[rr, "\switch_p"']\&\&
  u\tri p
\end{tikzcd}
\]
is translated tersely as left, or verbosely as right:
\[
  \begin{prooftree}
    \Hypo{I\vdash A\vdash B}
    \Infer1{I\to\Sigma(A,B)\equiv\Sigma(I\to A,I\to B)}
  \end{prooftree}
  \hspace{.6in}
  \begin{prooftree}
    \Hypo{I\vdash A\vdash B}
    \Infer1{(I\to\Sigma(A,B)\vdash I)\equiv(\Sigma(I\to A,I\to B)\vdash I)}
  \end{prooftree}  
\]
From the verbose version we also get a derivation rule backwards on terms:
\[
  \begin{prooftree}
    \Hypo{(a,b),i}
    \Infer1{i,ai,bi}
  \end{prooftree}
\]

The final diagram \eqref{eqn.key_med2}
\[
\begin{tikzcd}[column sep=large, ampersand replacement=\&]
	p\tri (u\otimes u)\ar[r, "\ol{\switch}_{p,u}"]\ar[d, "p\tri{(-,-)}"']\&
	u\otimes p\tri u\ar[r, "u\otimes\ol\switch_{p,\yon}"]
	\&u\otimes u\otimes p\ar[d, "{(-,-)}\otimes p"]\\
	p\tri u\ar[rr, "\ol\switch_{p,\yon}"']
	\&\&
	u\otimes p
\end{tikzcd}
\]
is translated tersely as left, or verbosely as right:
\[
  \begin{prooftree}
    \Hypo{I\vdash (A, B)}
    \Infer1{I\to(A,B)\equiv(I\to A,I\to B)}
  \end{prooftree}
\hspace{.6in}
 \begin{prooftree}
    \Hypo{I\vdash (A, B)}
    \Infer1{(I\to(A,B),I)\equiv((I\to A,I\to B),I)}
  \end{prooftree}
\]
From the verbose version we also get a derivation rule backwards on terms:
\[
  \begin{prooftree}
    \Hypo{(a,b),i}
    \Infer1{i,ai,bi}
  \end{prooftree}
\]
Again this looks exactly like the above case of $\Sigma$ in place of $(-,-)$, which means that ambiguities in our notational system are appropriately washed away.

%-------- Chapter --------%
\chapter{Future work}

One may hope to generalize the above considerations to polynomial universes in arbitrary copresheaf categories $\cat{C}\set$. A first question is how to define polynomials in that context, because there are two reasonable generalizations. One is the usual one, which comes from maps $E\to B$ in $\cat{C}\set$; the other is that of parametric right adjoint functors $\cat{C}\set\to\cat{C}\set$, which is strictly more general for nondiscrete $\cat{C}$. 

Preliminary work suggests that $\poly$ should be replaced by the category $\cat{C}\set[\cat{C}]$ of parametric right adjoints $\cat{C}\set\to\cat{C}\set$; see \cite{spivak2021functorial}. In the case $\cat{C}=1$, this yields $1\set[1]\cong\poly$. It seems that $\polycart$ should be replaced by the comma category (lax pullback) $(\cat{C}\downarrow\{\smset\})$ associated to the diagram of categories (not 2-categories)
\[\cat{C}\set\To{\text{elts}}\smcat\From{\smset}\{*\}.\]
In the case $\cat{C}=1$, this yields $\polycart$. Denoting the image of its inclusion into $\cat{C}\set[\cat{C}]$ as $\cat{C}\set[\cat{C}]^{\Cat{cart}}$,  it appears that everything in the diagram
\[
\begin{tikzcd}[column sep=60pt]
	\Big(\cat{C}\set[\cat{C}]^{\Cat{cart}},\id, \circ\Big)
		\ar[r, bend left=15pt,  start anchor={north east}, end anchor={north west}, "p\mapsto u\otimes p\circ-", ""' name=P]
		\ar[r, bend right=15pt, start anchor={south east}, end anchor={south west}, "p\mapsto u\circ p\circ-"', "" name=PP]&
	\Big(\en(\cat{C}\set[\cat{C}]),\id,\circ\Big)
	\ar[from=P, to=P|-PP, Rightarrow, shorten=2mm, "\indep"]
\end{tikzcd}
\]
makes sense, though it is unclear whether the usual definition of universes fits in as $u$ and makes everything appropriately monoidal. 




\printbibliography
\end{document}
