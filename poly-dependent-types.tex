\documentclass[11pt, one side, article]{memoir}


\settrims{0pt}{0pt} % page and stock same size
\settypeblocksize{*}{34.5pc}{*} % {height}{width}{ratio}
\setlrmargins{*}{*}{1} % {spine}{edge}{ratio}
\setulmarginsandblock{.98in}{.98in}{*} % height of typeblock computed
\setheadfoot{\onelineskip}{2\onelineskip} % {headheight}{footskip}
\setheaderspaces{*}{1.5\onelineskip}{*} % {headdrop}{headsep}{ratio}
\checkandfixthelayout


\usepackage{amsthm}
\usepackage{mathtools}

\usepackage[inline]{enumitem}
\usepackage{ifthen}
\usepackage[utf8]{inputenc} %allows non-ascii in bib file
\usepackage{xcolor}

\usepackage[backend=biber, backref=true, maxbibnames = 10, style = alphabetic]{biblatex}
\usepackage[bookmarks=true, colorlinks=true, linkcolor=blue!50!black,
citecolor=orange!50!black, urlcolor=orange!50!black, pdfencoding=unicode]{hyperref}
\usepackage[capitalize]{cleveref}

\usepackage{tikz}

\usepackage{amssymb}
\usepackage{newpxtext}
\usepackage[varg,bigdelims]{newpxmath}
\usepackage{mathrsfs}
\usepackage{dutchcal}
\usepackage{fontawesome}
\usepackage{ebproof}



% cleveref %
  \newcommand{\creflastconjunction}{, and\nobreakspace} % serial comma
  \crefformat{enumi}{\##2#1#3}
  \crefalias{chapter}{section}


% biblatex %
  \addbibresource{Library20211226.bib} 

% hyperref %
  \hypersetup{final}

% enumitem %
  \setlist{nosep}
  \setlistdepth{6}



% tikz %



  \usetikzlibrary{ 
  	cd,
  	math,
  	decorations.markings,
		decorations.pathreplacing,
  	positioning,
  	arrows.meta,
  	shapes,
		shadows,
		shadings,
  	calc,
  	fit,
  	quotes,
  	intersections,
    circuits,
    circuits.ee.IEC
  }
  
  \tikzset{
biml/.tip={Glyph[glyph math command=triangleleft, glyph length=.95ex]},
bimr/.tip={Glyph[glyph math command=triangleright, glyph length=.95ex]},
}

\tikzset{
	tick/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (0,.4ex) -- (0,-.4ex);}}}
  }
} 
\tikzset{
	slash/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (.3ex,.3ex) -- (-.3ex,-.3ex);}}}
  }
} 

\newcommand{\bito}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, biml-bimr, "#1"]\&~\end{tikzcd}  
}
\newcommand{\bifrom}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, bimr-biml, "{#1}"]\&~\end{tikzcd}  
}
\newcommand{\bifromlong}[2][]{
	\begin{tikzcd}[ampersand replacement=\&, column sep=#2, cramped]\ar[r, bimr-biml, "#1"]\&~\end{tikzcd}  
}

% Adjunctions
\newcommand{\adj}[5][30pt]{%[size] Cat L, Left, Right, Cat R.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]
  \ar[r, phantom, "\scriptstyle\Rightarrow"]\&
  #5\ar[l, shift left=7pt, "#4"]
\end{tikzcd}
}

\newcommand{\adjr}[5][30pt]{%[size] Cat R, Right, Left, Cat L.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]\&
  #5\ar[l, shift left=7pt, "#4"]
  \ar[l, phantom, "\scriptstyle\Leftarrow"]
\end{tikzcd}
}

\newcommand{\xtickar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}
\newcommand{\xslashar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}



  
  % amsthm %
\theoremstyle{definition}
\newtheorem{definitionx}{Definition}[chapter]
\newtheorem{examplex}[definitionx]{Example}
\newtheorem{remarkx}[definitionx]{Remark}
\newtheorem{notation}[definitionx]{Notation}


\theoremstyle{plain}

\newtheorem{theorem}[definitionx]{Theorem}
\newtheorem{proposition}[definitionx]{Proposition}
\newtheorem{corollary}[definitionx]{Corollary}
\newtheorem{lemma}[definitionx]{Lemma}
\newtheorem{warning}[definitionx]{Warning}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{proposition*}{Proposition}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{warning*}{Warning}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{construction}[theorem]{Construction}

\newenvironment{example}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\examplex}
  {\popQED\endexamplex}
  
 \newenvironment{remark}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\remarkx}
  {\popQED\endremarkx}
  
  \newenvironment{definition}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\definitionx}
  {\popQED\enddefinitionx} 

    
%-------- Single symbols --------%
	
\DeclareSymbolFont{stmry}{U}{stmry}{m}{n}
\DeclareMathSymbol\fatsemi\mathop{stmry}{"23}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}


%-------- Renewed commands --------%

\renewcommand{\ss}{\subseteq}

%-------- Other Macros --------%


\DeclarePairedDelimiter{\present}{\langle}{\rangle}
\DeclarePairedDelimiter{\copair}{[}{]}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\corners}{\ulcorner}{\urcorner}
\DeclarePairedDelimiter{\ihom}{[}{]}

\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Mor}{Mor}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\idy}{idy}
\DeclareMathOperator{\comp}{com}
\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\ob}{Ob}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\el}{El}




\newcommand{\const}[1]{\texttt{#1}}%a constant, or named element of a set
\newcommand{\Set}[1]{\mathsf{#1}}%a named set
\newcommand{\ord}[1]{\mathsf{#1}}%an ordinal
\newcommand{\cat}[1]{\mathcal{#1}}%a generic category
\newcommand{\Cat}[1]{\mathbf{#1}}%a named category
\newcommand{\fun}[1]{\mathrm{#1}}%a function
\newcommand{\Fun}[1]{\mathit{#1}}%a named functor




\newcommand{\id}{\mathrm{id}}
\newcommand{\then}{\mathbin{\fatsemi}}

\newcommand{\cocolon}{:\!}


\newcommand{\iso}{\cong}
\newcommand{\too}{\longrightarrow}
\newcommand{\tto}{\rightrightarrows}
\newcommand{\To}[2][]{\xrightarrow[#1]{#2}}
\renewcommand{\Mapsto}[1]{\xmapsto{#1}}
\newcommand{\Tto}[3][13pt]{\begin{tikzcd}[sep=#1, cramped, ampersand replacement=\&, text height=1ex, text depth=.3ex]\ar[r, shift left=2pt, "#2"]\ar[r, shift right=2pt, "#3"']\&{}\end{tikzcd}}
\newcommand{\Too}[1]{\xrightarrow{\;\;#1\;\;}}
\newcommand{\from}{\leftarrow}
\newcommand{\ffrom}{\leftleftarrows}
\newcommand{\From}[1]{\xleftarrow{#1}}
\newcommand{\Fromm}[1]{\xleftarrow{\;\;#1\;\;}}
\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\inj}{\rightarrowtail}
\newcommand{\wavyto}{\rightsquigarrow}
\newcommand{\lollipop}{\multimap}
\newcommand{\imp}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\down}{\mathbin{\downarrow}}
\newcommand{\fromto}{\leftrightarrows}
\newcommand{\tickar}{\xtickar{}}
\newcommand{\slashar}{\xslashar{}}



\newcommand{\inv}{^{-1}}
\newcommand{\op}{^\tn{op}}

\newcommand{\tn}[1]{\textnormal{#1}}
\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\wc}[1]{\widecheck{#1}}
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}



\newcommand{\bb}{\mathbb{B}}
\newcommand{\cc}{\mathbb{C}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\pp}{\mathbb{P}}
\newcommand{\qq}{\mathbb{Q}}
\newcommand{\zz}{\mathbb{Z}}
\newcommand{\rr}{\mathbb{R}}


\newcommand{\finset}{\Cat{Fin}}
\newcommand{\smset}{\Cat{Set}}
\newcommand{\smcat}{\Cat{Cat}}
\newcommand{\catsharp}{\Cat{Cat}^{\sharp}}
\newcommand{\ppolyfun}{\mathbb{P}\Cat{olyFun}}
\newcommand{\ccatsharp}{\mathbb{C}\Cat{at}^{\sharp}}
\newcommand{\ccatsharpdisc}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc}}}
\newcommand{\ccatsharplin}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{lin}}}
\newcommand{\ccatsharpdisccon}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc,con}}}
\newcommand{\sspan}{\mathbb{S}\Cat{pan}}
\newcommand{\en}{\Cat{End}}

\newcommand{\List}{\Fun{List}}
\newcommand{\set}{\tn{-}\Cat{Set}}




\newcommand{\yon}{\mathcal{y}}
\newcommand{\poly}{\Cat{Poly}}
\newcommand{\polycart}{\poly^{\Cat{Cart}}}
\newcommand{\ppoly}{\mathbb{P}\Cat{oly}}
\newcommand{\0}{\textsf{0}}
\newcommand{\1}{\tn{\textsf{1}}}
\newcommand{\U}{\tn{\textsf{U}}}
\newcommand{\tri}{\mathbin{\triangleleft}}
\newcommand{\triright}{\mathbin{\triangleright}}
\newcommand{\tripow}[1]{^{\tri #1}}
\newcommand{\indep}{\Fun{Indep}}



% lenses
\newcommand{\biglens}[2]{
     \begin{bmatrix}{\vphantom{f_f^f}#2} \\ {\vphantom{f_f^f}#1} \end{bmatrix}
}
\newcommand{\littlelens}[2]{
     \begin{bsmallmatrix}{\vphantom{f}#2} \\ {\vphantom{f}#1} \end{bsmallmatrix}
}
\newcommand{\lens}[2]{
  \relax\if@display
     \biglens{#1}{#2}
  \else
     \littlelens{#1}{#2}
  \fi
}



\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\qqand}{\qquad\text{and}\qquad}


\newcommand{\coto}{\nrightarrow}
\newcommand{\cofun}{{\raisebox{2pt}{\resizebox{2.5pt}{2.5pt}{$\setminus$}}}}

\newcommand{\coalg}{\tn{-}\Cat{Coalg}}

\newcommand{\bic}[2]{{}_{#1}\Cat{Comod}_{#2}}

% ---- Changeable document parameters ---- %

\linespread{1.1}
%\allowdisplaybreaks
\setsecnumdepth{section}
\settocdepth{section}
\setlength{\parindent}{15pt}
\setcounter{tocdepth}{1}



%--------------- Document ---------------%
\begin{document}

\title{Polynomial universes and dependent types}

\author{David I. Spivak}

\date{\vspace{-.2in}}

\maketitle

\begin{abstract}
\end{abstract}


%-------- Chapter --------%
\chapter{Introduction}

In this paper we ground the notion of dependent types in the theory of polynomial functors. The syntax and rules will all emerge from two pieces of data:
\begin{enumerate}
	\item A cartesian polynomial monad $(u,\1,\Sigma)$ and
	\item a certain lax monoidal functor $\Phi\coloneqq\Phi_u$, defined in terms of $u$, of the form%
\footnote{This can be phrased as an \emph{right-biased oplax monoidal structure} \cite{nlab.lax_monoidal} on $\polycart$, but we will only briefly mention this again.}
\[
\Phi_u\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\polycart),\id,\circ\Big)
\]
\end{enumerate}
The lax monoidality gives cartesian maps of the form 
\[
\Phi(p_1)\circ\Phi(p_2)
\Too{\aleph_{p_1,p_2}}
\Phi(p_1\tri p_2).
\]
These perform a kind of switching operation, which in fact does most of the work. In particular, we will apply this functor to the monad $u$ itself, compose with $\Sigma$, and apply it to $u\in\poly$ to obtain a cartesian map
\begin{equation}\label{eqn.main}
\Phi(u)\circ\Phi(u)(u)
\Too{\aleph_{u,u}(u)}
\Phi(u\tri u)(u)
\Too{\Sigma(u)}
\Phi(u)(u)
\end{equation}
which contains within it the most important structural rules of dependent type theory. For example, from the structure and axioms one can derive a self-distributivity law $u\tri u\to u\tri u$, as discussed in a \href{https://topos.site/blog/2021/07/jump-monads-from-conjugation-to-dependent-types/}{Topos Institute blog post}.

From \cref{eqn.main} we obtain the following sort of syntax and rules.%
\footnote{For typographical reasons, we are sparing with our parentheses. We use the convention that $\vdash$ binds the tightest, so $A,B\vdash C$ parses as $A,(B\vdash C)$. Thus, the expression $A, B\vdash (C, D\vdash E)$ parses as $A,(B\vdash(C, (D\vdash E)))$.}
\begin{equation}\label{eqn:premise_axiom}
  \begin{prooftree}
    \Hypo{A}
    \Infer1{\1\vdash A}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{A, B\vdash (C, D\vdash E)}
    \Infer1{(A,B\to C),\Sigma(B,D)\vdash E}
  \end{prooftree}
\end{equation}
The first says that for any type $A:\U$, one can form the unit type $\1$ and for any term $():[\1]$ a type $A():\U$ depending on it.%
\footnote{Here, $1$ denotes the one-element set and $\1$ denotes a certain element of $u$. We hope the reader can bear with us until we explain $u$ in the main text.}
 The second is more complex. Suppose given a type $A:\U$, a type $B:\U$, for every $b:[B]$ a type $Cb:\U$ and a type $Db:\U$, and for every $d:[Db]$ a type $Ebd:\U$. Then one can form a type $(A,B\to C)\in \U$, a type $\Sigma(B,D)\in \U$, and for every $(b, d)\in [\Sigma(B,D)]$ a type $E(b,d):\U$. 

The typing rules come along with term rules. 
\begin{equation}\label{eqn.premise_axiom}
  \begin{prooftree}
    \Hypo{a}
    \Infer1{(),a}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{a, b, (c, d, e)}
    \Infer1{(a,c), (b,d), e}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{(),a}
    \Infer1{a()}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{(a,c), (b,d), e}
    \Infer1{a,b,(cb, db ,e(b, db))}
  \end{prooftree}
\end{equation}

These are opaque---indeed, they are derived from the structure, not chosen---so we unpack them. Because the map in \eqref{eqn.main} is cartesian, all of the rules are bijections: any term on top has a unique one on the bottom. We have chosen two write both directions. Here's what the top-to-bottom rules in \eqref{eqn.premise_axiom} say:
\begin{enumerate}
	\item Suppose given a term $a:[A]$. Then there is a term $():\1$ and, depending on it a term $\lambda ().a:[A()]$. We usually denote $\lambda ().a$ simply by $a$.
	\item Suppose given a dependent sequence of terms $a:[A]$, $b:[B]$, $c:[C b]$, $d:[D b]$, $e: [E b d]$. Then there are terms $(a,\lambda b.cb):[(A,B\to C)]$, $(b, d):[\Sigma(B,D)]$, and $e:[E(b,d)]$. We usually denote $\lambda b.cb$ simply by $c$.
\end{enumerate}
The rules for types are only top-to-bottom, but the cartesianness of the map \eqref{eqn.main} means that there is a bijection between the associated sets of terms. Here's what the bottom-to-top rules in \eqref{eqn.premise_axiom} say
\begin{enumerate}[resume]
	\item Suppose given a dependent sequence of terms $():\1$, $a:[A()]$. Then there is a term $a():[A]$. We usually denote $a()$ simply by $a$.
	\item Suppose given a dependent sequence of terms $(a,c):[(A,B\to C)]$, $(b,d):[\Sigma(B,D)]$, and $e:[E(b,d)]$. Then there are terms $a:[A]$, $b:[B]$, $cb:[Cb]$, $db:[Db]$, and $e(b,db):[E b d]$.
\end{enumerate}

The germination of this idea came from \href{https://www.youtube.com/watch?v=RDuNIP4icKI\&t=10765s}{Steve Awodey's talk} at the 2021 Workshop on Polynomial Functors, an explication of ideas in work of Awodey and Newstead \cite{awodey2018polynomial}. Indeed, their paper contains much of what will be said here. The present work adds two things:
\begin{enumerate}
	\item Explicit syntax and rules for pair types, and
	\item a law---which seems to be missing from \cite{awodey2018polynomial}---that in their language would say%
	\footnote{In our language it would say 
	\[
	A\to\Sigma(B,C)\cong \Sigma(A\to B,A\to C).
	\]
	}
	\[
	\prod_{x:A}\sum_{y:B(x)}C(x,y)\cong\sum_{y:\prod_{x:A}B(x)}\prod_{x:A}C(x,y(x))
	\]
\end{enumerate}
such that everything in sight is derived from the structure of $\Phi_u(u)(u)$ (rather than a certain pseudomonad, as in Awodey-Newstead).

\section{Acknowledgments}


This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-20-1-0348.

%-------- Chapter --------%
\chapter{Background}


\begin{definition}[Polynomial functor]\label{def.poly}
Given a set $S$, we denote the corresponding representable functor by
\[\yon^S\coloneqq\smset(S,-)\colon\smset\to\smset,\]
e.g. $\yon^S(X)\coloneqq X^S$. In particular $\yon=\yon^1$ is the identity and $\yon^0=1$ is constant singleton.

A \emph{polynomial functor} is a functor $p\colon\smset\to\smset$ that is isomorphic to a sum of representables, i.e.\ for which there exists a set $I$, a set $p[i]\in\smset$ for each $i\in I$, and an isomorphism
\[
p\cong\sum_{i\in I}\yon^{p[i]}.
\]
We call $I$ the set of \emph{$p$-positions}, and for each position $i\in I$ we call $p[i]$ the set of \emph{$p$-directions at $i$}. 

A \emph{morphism} $\varphi\colon p\to q$ of polynomial functors is simply a natural transformation between them. We denote the category of polynomial functors by $\poly$. It is called \emph{cartesian} if for every map of sets $f\colon S\to T$, the naturality square
\[
\begin{tikzcd}
  p(S)\ar[r, "p(f)"]\ar[d, "\varphi(S)"']&p(T)\ar[d, "\varphi(T)"]\\
  q(S)\ar[r, "q(f)"']&q(T)\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\]
is a pullback of sets. We denote the wide subcategory of polynomials and cartesian maps by $\polycart$.
\end{definition}

For any polynomial $p=\sum_{i\in I}\yon^{p[i]}$, we have a canonical isomorphism $p(1)\cong I$; hence we generally denote $p$ by
\begin{equation}\label{eqn.poly_notation}
p=\sum_{i\in p(1)}\yon^{p[i]}.
\end{equation}

\begin{remark}
Note that there is already some dependency in \cref{def.poly}; in order to define a polynomial we need a set $I$ and then, \emph{for each $i$ in $I$}, we need a representable functor. In order to get the present paper off the ground, this much and a bit more---the following combinatorial description of morphisms---need to be granted.

Using the Yoneda lemma, we can understand a morphism $p\to q$ in $\poly$ to consist of two pieces $(\varphi_1,\varphi^\sharp)$ as follows:
\begin{equation}\label{eqn.mapsharp}
  \varphi_1\colon p(1)\to q(1)
  \qqand
  \varphi^\sharp_i\colon q[j]\to p[i]
\end{equation}
that is, $\varphi_1$ is a function on positions, and $\varphi^\sharp_i$ is a function on directions, \emph{depending on a position $i\in p(1)$}.
where $\varphi_1(i)=j$.
\end{remark}

\begin{example}\label{ex.u_kappa}
The easiest intuitive example to keep in mind for our paper will be 
\[u_\omega\coloneqq\sum_{N\in\nn}\yon^{N}\]
which will correspond to the universe of finite sets. 

Suppose $\kappa$ is an ordinal with the following properties for any ordinals $A$ and $B_1,\ldots,B_A$ with disjoint union $S(A,B)\coloneqq\coprod_{a\in A}B_a$ and cartesian product $P(A,B)\coloneqq\prod_{a\in A}B_a$:
\begin{enumerate}
	\item it is nonempty $1\leq\kappa$;
	\item it is closed under its own sums: if $A\leq\kappa$ and $B_1,\ldots,B_A\leq\kappa$, then $S(A,B)\leq\kappa$;
	\item it is closed under its own products: if $A\leq\kappa$ and $B_1,\ldots,B_A\leq\kappa$, then $P(A,B)\leq\kappa$.
\end{enumerate}
In this case $u_\kappa\coloneqq \sum_{N\leq\kappa}\yon^N$ will be a universe.

Note that $1$ satisfies the above properties, so $u_1=1+\yon$ is also an example, though it is a bit to easy to get much intuition from.
\end{example}


Polynomial functors are closed under composition, which we denote by $\tri$; the monoidal unit is $\yon$. There is another monoidal product called \emph{Dirichlet product} and denoted $\otimes$; it is given by
\[
\left(\sum_{i\in p(1)}\yon^{p[i]}\right)\otimes
\left(\sum_{j\in q(1)}\yon^{q[j]}\right)\coloneqq
\sum_{(i,j)\in p(1)\times q(1)}\yon^{p[i]\times q[i]}.
\]
Its monoidal unit is again $\yon$. 

The $\otimes$ structure is symmetric. Both monoidal structures restrict to monoidal structures on $\polycart$; in other words any composite or Dirichlet product of cartesian morphisms is again cartesian.

There is an identity-on-objects lax monoidal functor
\begin{equation}\label{eqn.indep}
(\poly,\yon,\tri)\to(\poly,\yon,\otimes),
\end{equation}
or equivalently an identity-on-objects oplax monoidal functor $(\poly,\yon,\otimes)\to(\poly,\yon,\tri)$. Given polynomials $p,q\in\poly$ and a set $X\in\smset$, we refer to the laxator (lax coherence maps) as
\[\indep\colon (p\otimes q)\to (p\tri q)\]
and is defined as follows. Suppose given an index $(i,j)\in p(1)\times q(1)$ and map $x\colon p[i]\times q[i]\to X$. An element of $(p\tri q)(X)$ is first a choice of index $i'\in p(1)$ and, for every $s\in p[i']$ a choice of index $j'\in q(1)$ and, for every $t\in q[j']$ a choice of $x'\in X$. We use $i'\coloneqq i$, independent of $s\in p[i']$ we use $j'\coloneqq j$, and we use $x'\coloneqq x(s,t)$. One can check that $\indep$ is Cartesian.

\chapter{The monoidal functor $\Phi_u$}

\section{The requirements on $\Phi_u$}
By this point, the type 
\[
\Phi\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\polycart),\id,\circ\Big)
\]	
of the lax monoidal functor $\Phi\coloneqq\Phi_u$ can be understood for any polynomial $u\in\poly$. First of all, its domain is the category $\polycart$ of polynomials and cartesian maps between them. Its codomain is $\en(\polycart)$, the category of functors $\polycart\to\polycart$. The functor being lax monoidal with respect to $(\yon,\tri)$ means that there are cartesian maps
\[
q\to\Phi(\yon)(q)
\qqand
(\Phi(p_1)\circ\Phi(p_2))(q)\to \Phi(p_1\tri p_2)(q).
\]
natural in $p_1,p_2,q$.  These must satisfy three commutative diagrams:
\[
\begin{tikzcd}
	\Phi(p_1)\circ\Phi(p_2)\circ\Phi(p_3)\ar[r]\ar[d]&
	\Phi(p_1)\circ\Phi(p_2\tri p_3)\ar[d]\\
	\Phi(p_1\tri p_2)\circ\Phi(p_3)\ar[r]&
	\Phi(p_1\tri p_2\tri p_3)
\end{tikzcd}
\]
and
\[
\begin{tikzcd}
	\id\circ\Phi(p)\ar[r]\ar[d, equal]&
	\Phi(\yon)\circ\Phi(p)\ar[d]\\
	\Phi(p)&\Phi(\yon\tri p)\ar[l]
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}
	\Phi(p)\circ\id\ar[r]\ar[d, equal]&
	\Phi(p)\circ\Phi(\yon)\ar[d]\\
	\Phi(p)&\Phi(p\tri\yon)\ar[l]
\end{tikzcd}
\]

\section{The action of $\Phi_u$ on objects and morphisms}

Our next step is to propose such a functor
\[
\Phi\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\polycart),\id,\circ\Big).
\]
It may look a bit underwhelming, but here it is:%
\footnote{For typographical reasons, we are sparing with our parentheses. We use the convention that $\tri$ binds the tightest, so $u\otimes p\tri q$ parses as $u\otimes(p\tri q)$. Thus, an expression such as $u\otimes u\tri(u\otimes u\tri p)$ parses as $u\otimes(u\tri(u\otimes(u\tri p)))$. The expression $p_1\tri q+p_2\tri q$ parses as $(p_1\tri q)+(p_2\tri q)$.}
\begin{equation}\label{eqn.define_phi}
\Phi_u(p)(q)\coloneqq u\otimes p\tri q.
\end{equation}
This is functorial in $p$ and $q$ by \cref{**}.

Let $u\in\poly$ be a polynomial and let $\1\colon\yon\to u$ and $\Sigma\colon u\tri u\to u$ be a cartesian monad structure on it. Note that since lax monoidal functors, such as $\indep$ from \eqref{eqn.indep}, send monoids to monoids. Hence, we also have a monad structure $\1\colon\yon\to u$ and 
\[
u\otimes u\to u\tri u\To{\Sigma}u.
\]
We denote it simply using parens: $(-,-)\colon u\otimes u\to u$.

\begin{example}
We resume our previous example, \cref{ex.u_kappa}; let $u=u_\kappa$ and recall the notation $S(A,B)\cong\coprod_{a\in A}B_a$.

The function $\1\colon\yon\to u$ sends the unique position in $\yon$ to the ordinal $1$. This map is cartesian. 

The function $\Sigma_1\colon u\tri u(1)\to u(1)$ is defined on tuples $(A,B)\in u_\kappa\tri u_\kappa(1)$. Here $B$ denotes a function $B\colon u_\kappa[A]\to u(1)$. We define it to the coproduct $\Sigma_1(A,B)\coloneqq S(A,B)$. The map $\Sigma_{(A,B)}^\sharp\colon S(A,B)\to (u\tri u)[(A,B)]$ sends $x\in \Sigma(A,B)$ to the pair $(x_A,x_B)$, where $x_A\in A$ and $x_B\in B x_A$; it is a bijection by definition, so $\Sigma$ is cartesian as well.

We generally denote $\Sigma_1$ simply by $\Sigma$ whenever confusion is not likely. Note that $\Sigma(\1,B)=B$; on positions it is literal equality, since the ordinal $\kappa$ has one element for every ordinal less than it. On directions it is also literal equality between the two functions. Similarly, $\Sigma(B,\1)=B$ and $\Sigma(A,\Sigma(B,C))=\Sigma(\Sigma(A,B),C)$. 
\end{example}

We now give the key lemma. It is defined by multiplying together types in $u$. The unexpected thing about this map is that to define it requires we use what we call \emph{overflow}. It says that if you try to multiply too many things together, and the result is not a type in $u$, then define the result to be the empty type. One could instead restrict the domain (the sort of $p$ one is allowed to use), but then the statement becomes less attractive. We also think it is an interesting feature to include overflow values.

\begin{lemma}[Key lemma]
For any polynomials $p\in\polycart$ and $q\in\poly$, there is a natural map 
\[\varphi_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q.\] 
Moreover, the following diagrams commute:
\begin{gather*}
\begin{tikzcd}[column sep=0, ampersand replacement=\&]
	\&p\tri q\ar[dl, "p\tri(\1\otimes q)"']\ar[dr,"\1\otimes p\tri q"]\\
	p\tri(u\otimes q)\ar[rr, "\varphi_{p,q}"']\&\&u\otimes p\tri q
\end{tikzcd}
\\
\begin{tikzcd}[, ampersand replacement=\&, column sep=large]
	p\tri(u\otimes u\otimes q)\ar[r, "\varphi_{p,u\otimes q}"]\ar[d, "p\tri{((-,-)\otimes q)}"']\&
	u\otimes p\tri(u\otimes q)\ar[r, "u\otimes\varphi_{p,q}"]\&
	u\otimes u\otimes p\tri q\ar[d, "{(-,-)}\otimes p\tri q"]\\
	p\tri (u\otimes q)\ar[rr, "\varphi_{p,q}"']\&\&
	u\otimes p\tri q
\end{tikzcd}
\end{gather*}
\end{lemma}
\begin{proof}
We first define the map $\varphi_{p,q}$, then show it is natural, and finally check the two diagrams. 
\end{proof}

\begin{theorem}
The functor $\Phi_u$ from \eqref{eqn.define_phi} is lax monoidal with respect to $(\yon,\tri)$.
\end{theorem}
\begin{proof}
**
\end{proof}

\printbibliography
\end{document}
