\documentclass[11pt, one side, article]{memoir}


\settrims{0pt}{0pt} % page and stock same size
\settypeblocksize{*}{34.5pc}{*} % {height}{width}{ratio}
\setlrmargins{*}{*}{1} % {spine}{edge}{ratio}
\setulmarginsandblock{.98in}{.98in}{*} % height of typeblock computed
\setheadfoot{\onelineskip}{2\onelineskip} % {headheight}{footskip}
\setheaderspaces{*}{1.5\onelineskip}{*} % {headdrop}{headsep}{ratio}
\checkandfixthelayout


\usepackage{amsthm}
\usepackage{mathtools}

\usepackage[inline]{enumitem}
\usepackage{ifthen}
\usepackage[utf8]{inputenc} %allows non-ascii in bib file
\usepackage{xcolor}

\usepackage[backend=biber, backref=true, maxbibnames = 10, style = alphabetic]{biblatex}
\usepackage[bookmarks=true, colorlinks=true, linkcolor=blue!50!black,
citecolor=orange!50!black, urlcolor=orange!50!black, pdfencoding=unicode]{hyperref}
\usepackage[capitalize]{cleveref}

\usepackage{tikz}

\usepackage{amssymb}
\usepackage{newpxtext}
\usepackage[varg,bigdelims]{newpxmath}
\usepackage{mathrsfs}
\usepackage{dutchcal}
\usepackage{fontawesome}
\usepackage{ebproof}



% cleveref %
  \newcommand{\creflastconjunction}{, and\nobreakspace} % serial comma
  \crefformat{enumi}{\##2#1#3}
  \crefalias{chapter}{section}


% biblatex %
  \addbibresource{Library20211226.bib} 

% hyperref %
  \hypersetup{final}

% enumitem %
  \setlist{nosep}
  \setlistdepth{6}



% tikz %



  \usetikzlibrary{ 
  	cd,
  	math,
  	decorations.markings,
		decorations.pathreplacing,
  	positioning,
  	arrows.meta,
  	shapes,
		shadows,
		shadings,
  	calc,
  	fit,
  	quotes,
  	intersections,
    circuits,
    circuits.ee.IEC
  }
  
  \tikzset{
biml/.tip={Glyph[glyph math command=triangleleft, glyph length=.95ex]},
bimr/.tip={Glyph[glyph math command=triangleright, glyph length=.95ex]},
}

\tikzset{
	tick/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (0,.4ex) -- (0,-.4ex);}}}
  }
} 
\tikzset{
	slash/.style={postaction={
  	decorate,
    decoration={markings, mark=at position 0.5 with
    	{\draw[-] (.3ex,.3ex) -- (-.3ex,-.3ex);}}}
  }
} 

\newcommand{\bito}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, biml-bimr, "#1"]\&~\end{tikzcd}  
}
\newcommand{\bifrom}[1][]{
	\begin{tikzcd}[ampersand replacement=\&, cramped]\ar[r, bimr-biml, "{#1}"]\&~\end{tikzcd}  
}
\newcommand{\bifromlong}[2][]{
	\begin{tikzcd}[ampersand replacement=\&, column sep=#2, cramped]\ar[r, bimr-biml, "#1"]\&~\end{tikzcd}  
}

% Adjunctions
\newcommand{\adj}[5][30pt]{%[size] Cat L, Left, Right, Cat R.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]
  \ar[r, phantom, "\scriptstyle\Rightarrow"]\&
  #5\ar[l, shift left=7pt, "#4"]
\end{tikzcd}
}

\newcommand{\adjr}[5][30pt]{%[size] Cat R, Right, Left, Cat L.
\begin{tikzcd}[ampersand replacement=\&, column sep=#1]
  #2\ar[r, shift left=7pt, "#3"]\&
  #5\ar[l, shift left=7pt, "#4"]
  \ar[l, phantom, "\scriptstyle\Leftarrow"]
\end{tikzcd}
}

\newcommand{\xtickar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}
\newcommand{\xslashar}[1]{\begin{tikzcd}[baseline=-0.5ex,cramped,sep=small,ampersand 
replacement=\&]{}\ar[r,tick, "{#1}"]\&{}\end{tikzcd}}



  
  % amsthm %
\theoremstyle{definition}
\newtheorem{definitionx}{Definition}[chapter]
\newtheorem{examplex}[definitionx]{Example}
\newtheorem{remarkx}[definitionx]{Remark}
\newtheorem{notation}[definitionx]{Notation}


\theoremstyle{plain}

\newtheorem{theorem}[definitionx]{Theorem}
\newtheorem{proposition}[definitionx]{Proposition}
\newtheorem{corollary}[definitionx]{Corollary}
\newtheorem{lemma}[definitionx]{Lemma}
\newtheorem{warning}[definitionx]{Warning}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{proposition*}{Proposition}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{warning*}{Warning}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{construction}[theorem]{Construction}

\newenvironment{example}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\examplex}
  {\popQED\endexamplex}
  
 \newenvironment{remark}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\remarkx}
  {\popQED\endremarkx}
  
  \newenvironment{definition}
  {\pushQED{\qed}\renewcommand{\qedsymbol}{$\lozenge$}\definitionx}
  {\popQED\enddefinitionx} 

    
%-------- Single symbols --------%
	
\DeclareSymbolFont{stmry}{U}{stmry}{m}{n}
\DeclareMathSymbol\fatsemi\mathop{stmry}{"23}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}


%-------- Renewed commands --------%

\renewcommand{\ss}{\subseteq}

%-------- Other Macros --------%


\DeclarePairedDelimiter{\present}{\langle}{\rangle}
\DeclarePairedDelimiter{\copair}{[}{]}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\corners}{\ulcorner}{\urcorner}
\DeclarePairedDelimiter{\ihom}{[}{]}

\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Mor}{Mor}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\idy}{idy}
\DeclareMathOperator{\comp}{com}
\DeclareMathOperator*{\colim}{colim}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\ob}{Ob}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\el}{El}




\newcommand{\const}[1]{\texttt{#1}}%a constant, or named element of a set
\newcommand{\Set}[1]{\mathsf{#1}}%a named set
\newcommand{\ord}[1]{\mathsf{#1}}%an ordinal
\newcommand{\cat}[1]{\mathcal{#1}}%a generic category
\newcommand{\Cat}[1]{\mathbf{#1}}%a named category
\newcommand{\fun}[1]{\mathrm{#1}}%a function
\newcommand{\Fun}[1]{\mathit{#1}}%a named functor




\newcommand{\id}{\mathrm{id}}
\newcommand{\then}{\mathbin{\fatsemi}}

\newcommand{\cocolon}{:\!}


\newcommand{\iso}{\cong}
\newcommand{\too}{\longrightarrow}
\newcommand{\tto}{\rightrightarrows}
\newcommand{\To}[2][]{\xrightarrow[#1]{#2}}
\renewcommand{\Mapsto}[1]{\xmapsto{#1}}
\newcommand{\Tto}[3][13pt]{\begin{tikzcd}[sep=#1, cramped, ampersand replacement=\&, text height=1ex, text depth=.3ex]\ar[r, shift left=2pt, "#2"]\ar[r, shift right=2pt, "#3"']\&{}\end{tikzcd}}
\newcommand{\Too}[1]{\xrightarrow{\;\;#1\;\;}}
\newcommand{\from}{\leftarrow}
\newcommand{\ffrom}{\leftleftarrows}
\newcommand{\From}[1]{\xleftarrow{#1}}
\newcommand{\Fromm}[1]{\xleftarrow{\;\;#1\;\;}}
\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\inj}{\rightarrowtail}
\newcommand{\wavyto}{\rightsquigarrow}
\newcommand{\lollipop}{\multimap}
\newcommand{\imp}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\down}{\mathbin{\downarrow}}
\newcommand{\fromto}{\leftrightarrows}
\newcommand{\tickar}{\xtickar{}}
\newcommand{\slashar}{\xslashar{}}



\newcommand{\inv}{^{-1}}
\newcommand{\op}{^\tn{op}}

\newcommand{\tn}[1]{\textnormal{#1}}
\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\wc}[1]{\widecheck{#1}}
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}



\newcommand{\bb}{\mathbb{B}}
\newcommand{\cc}{\mathbb{C}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\pp}{\mathbb{P}}
\newcommand{\qq}{\mathbb{Q}}
\newcommand{\zz}{\mathbb{Z}}
\newcommand{\rr}{\mathbb{R}}


\newcommand{\finset}{\Cat{Fin}}
\newcommand{\smset}{\Cat{Set}}
\newcommand{\smcat}{\Cat{Cat}}
\newcommand{\catsharp}{\Cat{Cat}^{\sharp}}
\newcommand{\ppolyfun}{\mathbb{P}\Cat{olyFun}}
\newcommand{\ccatsharp}{\mathbb{C}\Cat{at}^{\sharp}}
\newcommand{\ccatsharpdisc}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc}}}
\newcommand{\ccatsharplin}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{lin}}}
\newcommand{\ccatsharpdisccon}{\mathbb{C}\Cat{at}^{\sharp}_{\tn{disc,con}}}
\newcommand{\sspan}{\mathbb{S}\Cat{pan}}
\newcommand{\en}{\Cat{End}}

\newcommand{\List}{\Fun{List}}
\newcommand{\set}{\tn{-}\Cat{Set}}




\newcommand{\yon}{\mathcal{y}}
\newcommand{\poly}{\Cat{Poly}}
\newcommand{\polycart}{\poly^{\Cat{Cart}}}
\newcommand{\ppoly}{\mathbb{P}\Cat{oly}}
\newcommand{\0}{\textsf{0}}
\newcommand{\1}{\tn{\textsf{1}}}
\newcommand{\U}{\tn{\textsf{U}}}
\newcommand{\tri}{\mathbin{\triangleleft}}
\newcommand{\triright}{\mathbin{\triangleright}}
\newcommand{\tripow}[1]{^{\tri #1}}
\newcommand{\indep}{\Fun{Indep}}



% lenses
\newcommand{\biglens}[2]{
     \begin{bmatrix}{\vphantom{f_f^f}#2} \\ {\vphantom{f_f^f}#1} \end{bmatrix}
}
\newcommand{\littlelens}[2]{
     \begin{bsmallmatrix}{\vphantom{f}#2} \\ {\vphantom{f}#1} \end{bsmallmatrix}
}
\newcommand{\lens}[2]{
  \relax\if@display
     \biglens{#1}{#2}
  \else
     \littlelens{#1}{#2}
  \fi
}



\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\qqand}{\qquad\text{and}\qquad}


\newcommand{\coto}{\nrightarrow}
\newcommand{\cofun}{{\raisebox{2pt}{\resizebox{2.5pt}{2.5pt}{$\setminus$}}}}

\newcommand{\coalg}{\tn{-}\Cat{Coalg}}

\newcommand{\bic}[2]{{}_{#1}\Cat{Comod}_{#2}}

% ---- Changeable document parameters ---- %

\linespread{1.1}
%\allowdisplaybreaks
\setsecnumdepth{section}
\settocdepth{section}
\setlength{\parindent}{15pt}
\setcounter{tocdepth}{1}



%--------------- Document ---------------%
\begin{document}

\title{Polynomial universes and dependent types}

\author{David I. Spivak}

\date{\vspace{-.2in}}

\maketitle

\begin{abstract}
\end{abstract}


%-------- Chapter --------%
\chapter{Introduction}

In this paper we ground the notion of dependent types in the theory of polynomial functors. We split it into two pieces: the main structure and the auxiliary structure: the first handles dependent sums, dependent products, and the interaction between them. The second adds explicit support for pair (non-dependent sum) types. 

The main syntax and rules will emerge from two pieces of data:
\begin{enumerate}
	\item A cartesian polynomial monad $(u,\1,\Sigma)$ and
	\item a certain lax monoidal functor $\Phi\coloneqq\Phi_u$, defined in terms of $u$, of the form
	%
%\footnote{This can be phrased as an \emph{right-biased oplax monoidal structure} \cite{nlab.lax_monoidal} on $\polycart$, but we will only briefly mention this again.}
\[
\Phi_u\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\poly),\id,\circ\Big)
\]
\end{enumerate}
The lax monoidality gives cartesian maps of the form 
\[
\Phi(p_1)\circ\Phi(p_2)
\Too{\phi_{p_1,p_2}}
\Phi(p_1\tri p_2).
\]
These perform a kind of switching operation, which in fact does most of the work. In particular, we will apply this functor to the monad $u$ itself, compose with $\Sigma$, and apply it to $u\in\poly$ to obtain a map
\begin{equation}\label{eqn.main}
  \Phi(u)\circ\Phi(u)(u)
  \Too{\phi_{u,u}(u)}
  \Phi(u\tri u)(u)
  \Too{\Sigma(u)}
  \Phi(u)(u)
\end{equation}
which contains within it the most important structural rules of dependent type theory. For example, from the structure and axioms one can derive a self-distributivity law $u\tri u\to u\tri u$, as discussed in a \href{https://topos.site/blog/2021/07/jump-monads-from-conjugation-to-dependent-types/}{Topos Institute blog post}.

The auxiliary structure is a second lax monoidal functor and lax natural transformation as shown:
\begin{equation}\label{eqn.aux}
\begin{tikzcd}[row sep=0]
	\Big(\polycart,\yon,\tri\Big)\ar[dd, "\indep"']\ar[dr, bend left=5pt, "\Phi_u", ""' name=Phi]\\&[30pt]
	\Big(\en(\poly),\id,\circ\Big)\\
	\Big(\polycart,\yon,\otimes\Big)\ar[ur, bend right=5pt, "\Psi_u"', "" name=Psi]
	\ar[from=Phi, to=Psi-|Phi, shorten=2mm, Rightarrow, "\indep"']
\end{tikzcd}
\end{equation}
The idea is that a pair type $(A,B)$ can be considered as a dependent type $A\vdash B$; so independent types include into dependent types.%
\footnote{The fact that the map seems to go the other way---from the $\tri$-structure to the $\otimes$-structure---is just an artifact of how lax monoidal functors work. The map $\indep$ is identity on objects and its laxators give maps $p\otimes q=\indep(p)\otimes\indep(q)\to\indep(p\tri q)=p\tri q$.
} 
We will explain all this in the main text; for now, let's move on to what it means.

From these lax monoidal functors we obtain the following sort of constructors.%
\footnote{Every time a type depends on terms of a previous type, we use a turnstyle $\vdash$; thus there may be several turnstyles in a type definition, e.g.\ in \eqref{eqn.premise_axiom}. All of our symbols relate to some aspect of the underlying polynomial formalism, so some such notation seems forced on us, even though this convention appears to be uncommon. For typographical reasons, we are sparing with our parentheses. We use the convention that $\vdash$ binds the tightest, so $A,B\vdash C$ parses as $A,(B\vdash C)$. Thus, the expression $A, B\vdash (C, D\vdash E)$ parses as $A,(B\vdash(C, (D\vdash E)))$.}
\begin{equation}\label{eqn.premise_axiom}
  \begin{prooftree}
    \Hypo{A}
    \Infer1{\1\vdash A}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{A, B\vdash (C, D\vdash E)}
    \Infer1{(A,B\to C),\Sigma(B,D)\vdash E}
  \end{prooftree}
\end{equation}
The first says that for any type $A:\U$, one can form the unit type $\1$ and for any term $():[\1]$ a type $A():\U$ depending on it.%
\footnote{Here, $1$ denotes the one-element set and $\1$ denotes a certain element of $U$. In fact, they will turn out to somehow be the same, but we distinguish them for the reader's sake.}
 The second is more complex. Suppose given a type $A:\U$, a type $B:\U$, for every $b:[B]$ a type $Cb:\U$ and a type $Db:\U$, and for every $d:[Db]$ a type $Ebd:\U$. Then one can form a type $(A,B\to C)\in \U$, a type $\Sigma(B,D)\in \U$, and for every $(b, d)\in [\Sigma(B,D)]$ a type $E(b,d):\U$. We denote $\Sigma$ types, where the second type may depend on the first, by $\Sigma(A,B)$; we denote product types---a special case of $\Sigma$ types where the second type does not depend on the first---by $(A,B)$.

The typing constructors come along with term constructors going in the opposite direction. 
\begin{equation}\label{eqn.premise_axiom}
	\hspace{.5in}
  \begin{prooftree}
    \Hypo{(),a}
    \Infer1{a()}
  \end{prooftree}
\hspace{.5in}
  \begin{prooftree}
    \Hypo{(a,c), (b,d), e}
    \Infer1{a,b,(cb, db ,e(b, db))}
  \end{prooftree}
\end{equation}
These are opaque---indeed, they are derived from the structure, not chosen---so we unpack them. Here's what they say
\begin{enumerate}[label=(\roman*)]
	\item Suppose given a dependent sequence of terms $():\1$, $a:[A()]$. Then we can construct a term $a():[A]$. By forthcoming conversions, we denote $a()$ simply by $a$.
	\item Suppose given a dependent sequence of terms $(a,c):[(A,B\to C)]$, $(b,d):[\Sigma(B,D)]$, and $e:[E(b,d)]$. Then we can construct terms $a:[A]$, $b:[B]$, $cb:[Cb]$, $db:[Db]$, and $e(b,db):[E b d]$.
\end{enumerate}
There are also equalities between types, e.g.
\[
\begin{array}{lll}
	A=\1\to A&
		A\to(B,C)=(A\to B,A\to C)&
			A\to\Sigma(B,C)=\Sigma(A\to B,A\to C)\\
	()=A\to ()&
		(A,B)\to C=A\to B\to C&
			\Sigma(A,B)\to C=A\to B\to C
\end{array}
\]
which come with conversion rules for terms%
\footnote{In case it isn't clear, we denote the terms of product types and $\Sigma$-types in the same way, namely as pairs $(a,b):(A,B)$ or $(a,b):\Sigma(A,B)$. We denote terms of a function type $A\to B$ simply by the codomain, e.g. $b:A\to B$; we leave it implicit that $b$ is waiting for an input $a:A$ to obtain $ba:B$.}
\[\arraycolsep=1cm
\begin{array}{lll}
	a\equiv a()&
		(b,c)(a)\equiv (b(a),c(a))&
			(b,c)(a)\equiv (b(a),c(a))\\
	()\equiv()(a)&
		c(a,b)\equiv c a b&
			c(a,b)\equiv c a b
\end{array}
\]

The germination of this idea came from \href{https://www.youtube.com/watch?v=RDuNIP4icKI\&t=10765s}{Steve Awodey's talk} at the 2021 Workshop on Polynomial Functors, an explication of ideas in work of Awodey and Newstead \cite{awodey2018polynomial}. Indeed, their paper contains much of what will be said here. The present work adds two things:
\begin{enumerate}
	\item explicit syntax and rules for pair types, and
	\item the distributive law of $\Pi$ over $\Sigma$, which in their language would say%
	\footnote{In our language it would say 
	\[
	A\to\Sigma(B,C)\cong \Sigma(A\to B,A\to C).
	\]
	}
	\[
	\prod_{x:A}\sum_{y:B(x)}C(x,y)\cong\sum_{y:\prod_{x:A}B(x)}\prod_{x:A}C(x,y(x))
	\]
	They have derived the other law connecting $\Sigma$ and $\Pi$ (see \cite[Remark 4.2]{awodey2018polynomial}), but seem to be missing this one.%
	\footnote{\href{https://youtu.be/RDuNIP4icKI?t=13898}{Andr\'{e} Joyal's question following Steve Awodey's talk} was ``what happened to the distributivity law that we love between sum and product?" Steve said that he believed it was of the same form as the other laws they had derived, and that they get it for free. I have not seen this derivation; if it does arise for free from the structure of a pseudoalgebra in the sense of their paper, then this paper would lose most of its value.
	}
\end{enumerate}
such that everything in sight is derived from the structures in \eqref{eqn.main} and \eqref{eqn.aux} (rather than from a certain pseudomonad, as in Awodey-Newstead).

%---- Section ----%
\section{Acknowledgments}

I greatly appreciate the clarity of delivery and the insight behind Steve Awodey's talk at the 2021 Workshop on Polynomial Functors. It has been a major source of inspiration for the intervening year.

This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-20-1-0348.

%-------- Chapter --------%
\chapter{Background and key examples}

The main purpose of this section is to fix notation and provide a brief overview of polynomial functors in one variable. But we will also use this section to introduce our main polynomials of interest, which we call $\kappa$-list polynomials.

%---- Section ----%
\section{Basics}

\begin{definition}[Polynomial functor]\label{def.poly}
Given a set $S$, we denote the corresponding representable functor by
\[\yon^S\coloneqq\smset(S,-)\colon\smset\to\smset,\]
e.g. $\yon^S(X)\coloneqq X^S$. In particular $\yon=\yon^1$ is the identity and $\yon^0=1$ is constant singleton.

A \emph{polynomial functor} is a functor $p\colon\smset\to\smset$ that is isomorphic to a sum of representables, i.e.\ for which there exists a set $I$, a set $p[i]\in\smset$ for each $i\in I$, and an isomorphism
\[
p\cong\sum_{i\in I}\yon^{p[i]}.
\]
We call $I$ the set of \emph{$p$-positions}, and for each position $i\in I$ we call $p[i]$ the set of \emph{$p$-directions at $i$}. 

A \emph{morphism} $\varphi\colon p\to q$ of polynomial functors is simply a natural transformation between them. We denote the category of polynomial functors by $\poly$. It is called \emph{cartesian} if for every map of sets $f\colon S\to T$, the naturality square
\[
\begin{tikzcd}
  p(S)\ar[r, "p(f)"]\ar[d, "\varphi(S)"']&p(T)\ar[d, "\varphi(T)"]\\
  q(S)\ar[r, "q(f)"']&q(T)\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\]
is a pullback of sets. We denote the wide subcategory of polynomials and cartesian maps by $\polycart$.
\end{definition}

For any polynomial $p=\sum_{i\in I}\yon^{p[i]}$, we have a canonical isomorphism $p(1)\cong I$; hence we generally denote $p$ by
\begin{equation}\label{eqn.poly_notation}
p=\sum_{i\in p(1)}\yon^{p[i]}.
\end{equation}

\begin{remark}\label{rem.positions_and_directions}
Note that there is already some dependency in \cref{def.poly}; in order to define a polynomial we need a set $I$ and then, \emph{for each $i$ in $I$}, we need a representable functor. In order to get the present paper off the ground, this much and a bit more---the following combinatorial description of morphisms---need to be granted.

Using the Yoneda lemma, we can understand a morphism $p\to q$ in $\poly$ to consist of two pieces $(\varphi_1,\varphi^\sharp)$ as follows:
\begin{equation}\label{eqn.mapsharp}
  \varphi_1\colon p(1)\to q(1)
  \qqand
  \varphi^\sharp_i\colon q[j]\to p[i]
\end{equation}
that is, $\varphi_1$ is a function on positions, and $\varphi^\sharp_i$ is a function on directions, \emph{depending on a position $i\in p(1)$}.
where $\varphi_1(i)=j$. We refer to $\varphi^\sharp$ as the \emph{on-directions} function.

One can check that a map $\varphi\colon p\to q$ is cartesian iff the on-directions function $\varphi^\sharp_i$ is a bijection $p[i]\cong q[\varphi_1i]$ for each $i\in p(1)$.
\end{remark}



\begin{definition}[Sum-product sets and list polynomials]\label{def.sum_prod_set}
Let $\kappa$ be a set. We say that it is a \emph{sum-product set} if it satisfies the following properties for any sets $A$ and $(B_a)_{a\in A}$ with disjoint union $S(A,B)\coloneqq\coprod_{a\in A}B_a$ and cartesian product $\Pi(A,B)\coloneqq\prod_{a\in A}B_a$:%
\footnote{We write $S(A,B)$ rather than $\Sigma(A,B)$ because we already have used that symbol for a monad structure. Later we will define $\Sigma(A,B)$ to be this $S(A,B)$, so the distinction is not important.}
\begin{enumerate}[label=(\roman*)]
	\item $\kappa$ is nonempty $0<\kappa$;
	\item $\kappa$ is closed under its own sums: if $A<\kappa$ and each $B_a<\kappa$, then $S(A,B)<\kappa$;
	\item $\kappa$ is closed under its own products: if $A<\kappa$ and each $B_a<\kappa$, then $\Pi(A,B)<\kappa$;
	\item there exists a set $C_\kappa$ containing exactly one set of each cardinality $N<\kappa$.%
	\footnote{The set $C_\kappa$ is structure, not property, but any two choices will yield isomorphic list polynomials, so we are not concerned with the distinction here.}
\end{enumerate}

Given a sum-product set $\kappa$, we define the \emph{$\kappa$-list polynomial} to be
\[
  u_\kappa\coloneqq\sum_{N\in C_\kappa}\yon^N
\qedhere
\]
\end{definition}

\begin{example}\label{ex.sum_prod_set}
Given the axiom of choice, any Grothendieck universe is a sum-product set; indeed conditions (i) -- (iii) are satisfied for any Grothendieck universe, and (iv) is satisfied assuming the axiom of choice.

There is only one finite ordinal with the above properties, namely $\kappa=2$. Indeed, $0$ fails condition (i), $1$ fails condition (iii) because $\Pi(0,!)=1\not<1$, and any $2<\kappa<\omega$ fails condition (ii) because by induction $\Pi(\kappa-1,(\kappa-1,\kappa-1))\not<\kappa$.

The easiest intuitive example to keep in mind for our paper is $\kappa=\omega$, where $N<\omega$ iff $N$ is finite. The $\omega$-list polynomial is
\[
  u_\omega\coloneqq\sum_{N\in\nn}\yon^N.
\qedhere
\]
\end{example}

%---- Section ----%
\section{Composition and Dirichlet monoidal structures}

Polynomial functors are closed under composition, which we denote by $\tri$; the monoidal unit is $\yon$.

There is another monoidal product called \emph{Dirichlet product} and denoted $\otimes$; it is given by
\[
\left(\sum_{i\in p(1)}\yon^{p[i]}\right)\otimes
\left(\sum_{j\in q(1)}\yon^{q[j]}\right)\coloneqq
\sum_{(i,j)\in p(1)\times q(1)}\yon^{p[i]\times q[i]}.
\]
Its monoidal unit is again $\yon$. 

The $\otimes$ structure is symmetric. Both monoidal structures restrict to monoidal structures on $\polycart$; in other words any composite or Dirichlet product of cartesian morphisms is again cartesian.

\begin{proposition}\label{prop.indep}
The identity functor $\poly\to\poly$ can be regarded as a lax monoidal functor
\begin{equation}\label{eqn.indep}
	\indep\colon (\poly,\yon,\tri)\to(\poly,\yon,\otimes),
\end{equation}
Moreover the laxators (lax coherence maps), which we denote with the same symbol
\[\indep\colon (p\otimes q)\to (p\tri q)\]
are cartesian for any $p,q\in\poly$.
\end{proposition}
\begin{proof}
Suppose given polynomials $p,q\in\poly$ and a set $X\in\smset$; the only data in $\indep$ is in its laxator, which we define as follows. Suppose given an index $(i,j)\in p(1)\times q(1)$ and map $x\colon p[i]\times q[i]\to X$. An element of $(p\tri q)(X)$ is first a choice of index $i'\in p(1)$ and, for every $s\in p[i']$ a choice of index $j'\in q(1)$ and, for every $t\in q[j']$ a choice of $x'\in X$. We use $i'\coloneqq i$, independent of $s\in p[i']$ we use $j'\coloneqq j$, and we use $x'\coloneqq x(s,t)$. One can check that the relevant axioms are satisfied and that $\indep$ is cartesian.
\end{proof}

\begin{proposition}\label{prop.tri_dir_cartesian}
Both the $\tri$ and the $\otimes$ products preserve cartesian maps.
\end{proposition}
\begin{proof}
Suppose given cartesian maps $\alpha\colon p_1\to p_2$ and $\beta\colon q_1\to q_2$. Then $\alpha\tri\beta$ is cartesian using the pullback definition \cref{def.poly} and $\alpha\otimes\beta$ is cartesian using the bijection-on-directions criterion from \cref{rem.positions_and_directions}.
\end{proof}

\begin{proposition}[$\kappa$-list monads]\label{prop.list_monad}
For any sum-product set $\kappa$, there is a cartesian monad structure $(\1,\Sigma)$ on the $\kappa$-list polynomial $u_\kappa\in\polycart$.
\end{proposition}
\begin{proof}
Recall that $u_\kappa=\sum_{N\in C_\kappa}\yon^N$, where $C_\kappa$ is a choice of one set for every cardinality $N<\kappa$, and that for any $A<\kappa$ and $B_a<\kappa$ for each set in $(B_a)_{a\in A}$, the set $S(A,B)$ isomorphic to their disjoint union also satisfies $S(A,B)<\kappa$. 

The monoidal unit on $u_\kappa$ corresponds to the ordinal $\1<\kappa$, considered as a (cartesian) map $\yon\to u_\kappa$. The monoidal product $u_\kappa\tri u_\kappa\to u_\kappa$ sends $A\in u_\kappa(1)$ and $B\colon u_\kappa[A]\to u_\kappa(1)$ to $S(A,B)$. The monad laws are satisfied because coproduct is monoidal product and $u_\kappa$ has exactly one position (element in $C_\kappa$) for each cardinality $N<\kappa$. 
\end{proof}

For any sum-product set $\kappa$, we refer to the monad $(u_\kappa,\1,\Sigma)$ from \cref{prop.list_monad} as the \emph{$\kappa$-list monad}. Note that since lax monoidal functors, such as $\indep$ from \eqref{eqn.indep}, send monoids to monoids. Hence, we also have a monoid structure 
\begin{equation}\label{eqn.otimes_monoid}
	\yon\To{\1} u
	\qqand
	u\otimes u\To{\indep} u\tri u\To{\Sigma}u.
\end{equation}
We denote it simply using parens: $(-,-)\colon u\otimes u\to u$.


%-------- Chapter --------%
\chapter{The lax monoidal functor $\Phi_u$ for a universe $u$}

We repeat the diagram from \eqref{eqn.aux} for convenience.
\[
\begin{tikzcd}[row sep=0]
	\Big(\polycart,\yon,\tri\Big)\ar[dd, "\indep"']\ar[dr, bend left=5pt, "\Phi_u", ""' name=Phi]\\&[30pt]
	\Big(\en(\poly),\id,\circ\Big)\\
	\Big(\polycart,\yon,\otimes\Big)\ar[ur, bend right=5pt, "\Psi_u"', "" name=Psi]
	\ar[from=Phi, to=Psi-|Phi, shorten=2mm, Rightarrow, "\indep"']
\end{tikzcd}
\]
By this point, the types of everything in it can be understood for any polynomial $u\in\poly$. We already have the left-hand map $\indep$ from \cref{prop.indep}; as a functor it is identity on objects. 

Let's examine the functors $\Phi_u$ and $\Psi_u$. First of all, the domain in each case is the category $\polycart$ of polynomials and cartesian maps between them, and the codomain is $\en(\poly)$, the category of functors $\poly\to\poly$. The functors being lax monoidal with respect to $(\yon,\tri)$ means that there are maps
\begin{align*}
  q&\to\Phi(\yon)(q)
  &(\Phi(p_1)\circ\Phi(p_2))(q)&\to \Phi(p_1\tri p_2)(q)\\
  q&\to\Psi(\yon)(q)
  &(\Psi(p_1)\circ\Psi(p_2))(q)&\to \Psi(p_1\otimes p_2)(q)
\end{align*}
natural in $p_1,p_2,q$, satisfying the appropriate commutative diagrams. 

The natural transformation $\indep$ will give maps $\Phi_u(p)\to\Psi_u(p)$ for each $p\in\poly$, and these will be satisfy an additional commutative diagram.

%---- Section ----%
\section{The action of $\Phi_u$ and $\Psi_u$ on objects and morphisms}

For any polynomial $u$, our next step is to propose functors
\begin{align*}
	\Phi_u\colon\Big(\polycart,\yon,\tri\Big)&\too\Big(\en(\poly),\id,\circ\Big)\\
	\Psi_u\colon\Big(\polycart,\yon,\otimes\Big)&\too\Big(\en(\poly),\id,\circ\Big).
\end{align*}
It may look a bit underwhelming, but here they are:%
\footnote{For typographical reasons, we are sparing with our parentheses. We use the convention that $\tri$ binds the tightest, so $u\otimes p\tri q$ parses as $u\otimes(p\tri q)$. Thus, an expression such as $u\otimes u\tri(u\otimes u\tri p)$ parses as $u\otimes(u\tri(u\otimes(u\tri p)))$. The expression $p_1\tri q+p_2\tri q$ parses as $(p_1\tri q)+(p_2\tri q)$.}
\begin{equation}\label{eqn.define_phi}
	\Phi_u(p)(q)\coloneqq u\tri p\tri q
	\qqand
	\Psi_u(p)(q)\coloneqq u\otimes p\tri q.
\end{equation}

Both are functorial in $p\in\polycart$ and $q\in\poly$ by \cref{prop.tri_dir_cartesian} and the fact that $\otimes$ and $\tri$ are monoidal products.

\begin{definition}[Universe monads]\label{def.universe}
We say that a cartesian monad $(u,\1,\Sigma)$ has the structure of a \emph{universe for dependent types} if the functor $\Phi_u$ given by \eqref{eqn.define_phi} has a lax monoidal structure. 

We say it has \emph{support for pair types} if there is additionally a lax monoidal structure on $\Psi_u$ and a lax natural transformation as shown in \eqref{eqn.aux} above.
\end{definition}

We now give a supply of universe monads, namely those that come from sum-product sets, as in \cref{def.sum_prod_set}.

Our goal is to show that for any $\kappa$ as in \cref{ex.sum_prod_set}, the $\kappa$-list polynomial $u_\kappa$ is a universe in the sense of \cref{def.universe}.

\begin{example}
We resume our previous example, \cref{ex.sum_prod_set}; let $u=u_\kappa$ and recall the notation $S(A,B)\cong\coprod_{a\in A}B_a$.

The function $\1\colon\yon\to u$ sends the unique position in $\yon$ to the ordinal $1$. This map is cartesian. 

The function $\Sigma_1\colon u\tri u(1)\to u(1)$ is defined on tuples $(A,B)\in u_\kappa\tri u_\kappa(1)$. Here $B$ denotes a function $B\colon u_\kappa[A]\to u(1)$. We define it to the coproduct $\Sigma_1(A,B)\coloneqq S(A,B)$. The map $\Sigma_{(A,B)}^\sharp\colon S(A,B)\to (u\tri u)[(A,B)]$ sends $x\in \Sigma(A,B)$ to the pair $(x_A,x_B)$, where $x_A\in A$ and $x_B\in B x_A$; it is a bijection by definition, so $\Sigma$ is cartesian as well.

We generally denote $\Sigma_1$ simply by $\Sigma$ whenever confusion is not likely. Note that $\Sigma(\1,B)=B$; on positions it is literal equality, since the ordinal $\kappa$ has one element for every ordinal less than it. On directions it is also literal equality between the two functions. Similarly, $\Sigma(B,\1)=B$ and $\Sigma(A,\Sigma(B,C))=\Sigma(\Sigma(A,B),C)$. 
\end{example}

We now give the key lemma. It is defined by multiplying together types in $u$. The unexpected thing about this map is that to define it requires we use what we call \emph{overflow}. It says that if you try to multiply too many things together, and the result is not a type in $u$, then define the result to be the empty type. One could instead restrict the domain (the sort of $p$ one is allowed to use), but then the statement becomes less attractive. We also think it is an interesting feature to include overflow values.


%---- Section ----%
\section{The lax monoidal structure on $\Phi_u$}

Discussion of overflow and using $\kappa$-bounded polynomials...

\begin{lemma}[Key lemma]\label{lemma.key}
Let $u\coloneqq u_\kappa$ be the $\kappa$-list polynomial for a sum-product set $\kappa$. For any polynomials $p\in\polycart$, $q\in\poly$, there is a natural map 
\[\varphi_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q.\] 
Moreover, it commutes properly with composition
\[
	\varphi_{\yon}=\id
	\qqand
	\varphi_{p\tri p'}=\varphi_{p}\circ (p\tri\varphi_{p'}),
\]
and the following diagrams commute:
\begin{gather*}
\begin{tikzcd}[column sep=0, ampersand replacement=\&]
	\&p\tri q\ar[dl, "p\tri(\1\otimes q)"']\ar[dr,"\1\otimes p\tri q"]\\
	p\tri(u\otimes q)\ar[rr, "\varphi_{p,q}"']\&\&u\otimes p\tri q
\end{tikzcd}
\\[15pt]
\begin{tikzcd}[, ampersand replacement=\&, column sep=large]
	p\tri(u\otimes u\otimes q)\ar[r, "\varphi_{p,u\otimes q}"]\ar[d, "p\tri{((-,-)\otimes q)}"']\&
	u\otimes p\tri(u\otimes q)\ar[r, "u\otimes\varphi_{p,q}"]\&
	u\otimes u\otimes p\tri q\ar[d, "{(-,-)}\otimes p\tri q"]\\
	p\tri (u\otimes q)\ar[rr, "\varphi_{p,q}"']\&\&
	u\otimes p\tri q
\end{tikzcd}
\end{gather*}
\end{lemma}
\begin{proof}
We first define the map $\varphi_{p,q}$, then show it is natural, and finally check the two diagrams. To define the map, we will need the---so far unused---property of $\kappa$ that it is closed under its own products, i.e.\ that for any $A<\kappa$ and $(B_a)_{a\in A}$ with each $B_a<\kappa$, the product $\prod_{a\in A}B_a=\Pi(A,B)<\kappa$ is too.

Fix $p,q\in\polycart$. To give the map $\varphi\coloneqq\varphi_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q$, we first define its component $\varphi_1$ on positions. A position of $p\tri(u\otimes q)\to u\otimes p\tri q$ consists of a triple $(i,A,j)$ where $i\in p(1)$, $A\colon p[i]\to u(1)$, and $j\colon p[i]\to q(1)$. We want to define a position of $u\otimes p\tri q$, which consists of a triple $(A',i',j')$ where $A'\in u(1)$, $i'\in p(1)$, and $j'\colon p[i']\to q(1)$. We define $i'\coloneqq i$, $j'\coloneqq j$, and $A'$ as follows:
\begin{equation}\label{eqn.overflow}
  A'\coloneqq
  \begin{cases}
  	\Pi(p[i],A)&\tn{ if }\Pi(p[i],A)<\kappa\\
		0&\tn{ otherwise}
  \end{cases}
\end{equation}
In a case of $(i,A,j)$ for which the second condition is activated, we say that $\varphi$ \emph{overflows}; otherwise we say it \emph{succeeds}.

For the backwards map $\varphi^\sharp_{(i,A,j)}\colon (u\otimes p\tri q)[(A',i,j)]\to(p\tri(u\otimes q))[(i,A,j)]$ on directions, there are two cases. If $A'=0$ then $(u\otimes p\tri q)[(A',i,j)=0$, so there is a unique map; this is the sense in which ``overflow causes the system to halt''. Otherwise, we need a map
\begin{equation}\label{eqn.not_injective}
\prod_{s\in p[i]}A_s\times\sum_{s\in p[i]}q[js]\to\sum_{s\in p[i]}(A s)\times (js)
\end{equation}
and it is given by $(a,s,t)\mapsto(s,as,ts)$.%
\footnote{Note that the map $\varphi^\sharp_{(i,A,j)}$ is not generally injective, because for a given input $(a,s,t)$, most of the data in $a$ is discarded; hence $\varphi$ is not cartesian. This has nothing to do with overflow, and hence could not be avoided by merely restricting $\polycart$ to $\kappa$-bounded polynomials.}

The map $\varphi$ is clearly natural in $q\in\poly$. It would not be natural for arbitrary polynomial maps $\psi\colon p\to p'$ because of the overflow; however, it is natural when $\psi$ is cartesian. Indeed if $\psi_1(i)=i'$ then the bijection $\psi_i^\sharp$ extends to a bijection
\[\Pi(p[i],A)\cong\Pi(p'[i'],A)\]
and $\varphi$ overflows for one iff it does for the other.

It is easy to check that $\varphi_{\yon,q}=\id_{u\otimes q}$. The statement $\varphi_{p\tri p'}=\varphi_{p}\circ (p\tri\varphi_{p'})$ is shorthand for the commutativity of the following diagram, natural in $q$:
\[
\begin{tikzcd}[column sep=-10pt]
	&p\tri p'\tri(u\otimes q)\ar[dl, bend right=20pt, "p\tri\varphi_{p',q}"']\ar[dr, bend left=20pt, "\varphi_{p\tri p',q}"]\\
	p\tri (u\otimes p'\tri q)\ar[rr, "\varphi_{p,p'\tri q}"']&&
	u\otimes p\tri p'\tri q
\end{tikzcd}
\]
It suffices to show for any set $I$, sets $(I'_i)_{i\in I}$, and sets $(A_{i,i'})_{i\in I, i'\in I'_i}$ with $A_{i,i'}<\kappa$, that first there is a bijection
\[
	\Pi(\Sigma(I,I'),A)\cong\Pi(I,\Pi(I',A)),
\]
which there is, and that second the overflow handling agrees, as we now argue. If for any $i\in I$ there is an overflow in $\Pi(I'_i,A_i)$ then it will output $0$, and the product of anything with $0$ is $0$; hence the two sides agree that the result is $0$. Otherwise, if all $\Pi(I'_i,A_i)$ succeed, then if the mutual result is too big, both sides again agree that the result is $0$.

It remains to check the two diagrams. For the first diagram, suppose given $(i,j)\in p\tri q(1)$. Under the left-hand composite map it is sent to $(\Pi(p[i],\1),i,j)$ and under the right-hand map it is sent to $(\1,i,j)$; these are the same element of $C_\kappa$  since $\Pi(p[i],\1)$ is defined to be the isomorphic to a product of $\1$'s, which is isomorphic to $\1$. The maps on directions are also identical.

For the second diagram, suppose given $(i,A,B,j)\in p\tri(u\otimes u\otimes q)$, where $A,B\colon p[i]\to u(1)$ and $j\colon p[i]\to q(1)$. It is easy to check that under the left-hand composite map it is sent to $(A_1,i,j)$ and under the right-hand composite map it is sent to $(A_2,i,j)$, for some $A_1,A_2\in u(1)$. Assuming neither overflows, these are 
\[
  A_1\cong\Pi(p[i],A\times B)
  \qqand
	A_2\cong\Pi(p[i],A)\times\Pi(p[i],B)
\] 
respectively, and these sets are isomorphic (hence equal in $C_\kappa$). So it remains to deal with the overflow situations.

Note that $\Pi(p[i],A\times B)\cong\Pi(p[i],A)\times\Pi(p[i],B)$ are isomorphic, so one overflows iff the other does. If they overflow then $\Pi(p[i],A\times B)$ is too big, so $A_1=0$. In this case we also know that either $\Pi(p[i],A)$ or $\Pi(p[i],Ba)$ is too big, for some $a\in\Pi(p[i],A)$, by assumption on $\kappa$ (see \cref{def.sum_prod_set}). In the first case we will have $A_2=0\times\Pi(p[i],B)$ and in the second case we will have $A_2=\Pi(p[i],A\times 0)$; either way, the result is $0$. Hence the diagram commutes.
\end{proof}

\begin{theorem}
For any sum-product set $\kappa$, the $\kappa$-list monad is a universe monad. 
\end{theorem}
\begin{proof}
Let $\kappa$ be a sum-product set, $u\coloneqq u_\kappa$ the associated list polynomial, and $(\1,\Sigma)$ the list monad structure; see \cref{def.sum_prod_set,prop.list_monad}. By \cref{def.universe} we need to show that the functor
\[
  \Phi\colon\Big(\polycart,\yon,\tri\Big)\too\Big(\en(\poly),\id,\circ\Big),
\]
given by $\Phi(p): q\mapsto u\otimes p\tri q$, has a lax monoidal structure. Given $p_1,p_2\in\polycart$, we need to define natural transformations
\[
	\phi\colon\id\to\Phi(\yon)
	\qqand
	\phi_{p_1,p_2}\colon\Phi(p_1)\circ\Phi(p_2)\to\Phi(p_1\tri p_2),
\]
i.e. component maps $q\To{\phi_q} u\otimes q$ and $u\otimes p_1\tri(u\otimes p_2\tri q)\To{\phi_{p_1,p_2,q}}u\otimes(p_1\tri p_2\tri q)$, natural in $q\in\poly$. Recall from \eqref{eqn.otimes_monoid} that $u$ has a $\otimes$-monoid structure given by $\1$ and $(-,-)$. The ingredients to the lax monoidal structure are these and the maps $\varphi_{p,q}\colon p\tri(u\otimes q)\to u\otimes p\tri q$ from the key lemma, \ref{lemma.key}. We define them to be the dashed maps:
\[
\begin{tikzcd}
	q\ar[r, "\cong"]\ar[rd, bend right, dashed, "\phi_q"']&\yon\tri q\ar[d, "\1\otimes q"]\\&
	u\otimes q
\end{tikzcd}
\qqand
\begin{tikzcd}[column sep=50pt]
	u\otimes p_1\tri(u\otimes p_2\tri q)\ar[r, "u\otimes\varphi_{p_1,p_2\tri q}"]\ar[dr, bend right=18pt, dashed, "\phi_{p_1,p_2,q}"']&
	u\otimes u\otimes p_1\tri p_2\tri q\ar[d, "{(-,-)}\otimes p_1\tri p_2\tri q"]\\&
	u\otimes p_1\tri p_2\tri q
\end{tikzcd}
\]
It remains to show that these satisfy the three commutative diagrams of a lax monoidal functor.

We begin by showing that the unit diagrams commute for any $q\in\poly$:
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\otimes p\tri q\ar[r, "\phi_{u\otimes p\tri q}"]\ar[dr, bend right=20pt, equal]\&
	u\otimes u\otimes p\tri q \ar[d, "\phi_{\yon,p,q}"]\\
	\&
	u\otimes p\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\otimes p\tri q\ar[r, "u\otimes p\tri(\phi_q)"]\ar[dr, bend right=20pt, equal]\&
	u\otimes p\tri(u\otimes q)\ar[d, "\phi_{p,\yon,q}"]\\
	\&
	u\otimes p\tri q
\end{tikzcd}
\]
By \cref{lemma.key}, these reduce as follows:
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=45pt]
	u\otimes p\tri q\ar[r, "\1\otimes u\otimes p\tri q"]\ar[dr, bend right=20pt, equal]\&
	u\otimes u\otimes p\tri q \ar[d, "{(-,-)}\otimes p\tri q"]\\
	\&
	u\otimes p\tri q
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&, column sep=50pt]
	u\otimes p\tri q\ar[r, "u\otimes p\tri(\1\otimes q)"]\ar[d, equal]\ar[rd, "u\otimes\1\otimes p\tri q" description]\&
	u\otimes p\tri(u\otimes q)\ar[d, "u\otimes\varphi_{p,q}"]\\
	u\otimes p\tri q\&
	u\otimes u\otimes p\tri q\ar[l, "{(-,-)}\otimes p\tri q"]
\end{tikzcd}
\]
and both commute by the unit laws for the $\otimes$ monoid structure on $u$. We conclude by showing that the associativity diagram commutes for any $q\in\poly$:
\[
\begin{tikzcd}[ampersand replacement=\&, column sep=60pt]
	u\otimes p_1\tri(u\otimes p_2\tri(u\otimes p_3\tri q))
		\ar[r, "u\otimes p_1\tri\phi_{p_2,p_3,q}"]
		\ar[d, "\phi_{p_1,p_2,u\otimes p_3\tri q}"']\&
	u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)
		\ar[d, "\phi_{p_1,p_2\tri p_3,q}"]\\
	u\otimes p_1\tri p_2\tri(u\otimes p_3\tri q)
		\ar[r, "\phi_{p_1\tri p_2,p_3,q}"']\&
	u\otimes p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]
Unpacking this, we obtain the following diagram, where the four sides above agree with the four composite sides shown:%
\footnote{We label the maps merely by ``hints'' for space reasons; e.g. the top maps labeled $\varphi$ and $(-,-)$ are fully written as $u\otimes p_1\tri(u\otimes p_2\tri\varphi_{p_2,p_3\tri q})$ and $u\otimes p_1\tri((-,-)\otimes p_2\tri p_2\tri p_3)$.}
\[\fontsize{9.6pt}{9.6pt}\selectfont
\begin{tikzcd}
	u\otimes p_1\tri(u\otimes p_2\tri(u\otimes p_3\tri q))\ar[r, "\varphi"]\ar[dd, "\varphi"']&
	u\otimes p_1\tri(u\otimes u\otimes p_2\tri p_3\tri q)\ar[r, "{(-,-)}"]\ar[d, "\varphi"]&
	u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)\ar[dd, "\varphi"]\\&
	u\otimes u\otimes p_1\tri(u\otimes p_2\tri p_3\tri q)\ar[dd, "\varphi"]\\[-12pt]
	u\otimes u\otimes p_1\tri p_2\tri(u\otimes p_3\tri q)\ar[dd, "{(-,-)}"']\ar[ur, bend left=5pt, start anchor={north east}, "\varphi"]\ar[dr, bend right=5pt, start anchor={south east}, "\varphi_{p_1\tri p_2}"']&&
	u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[dd, "{(-,-)}"]\\[-12pt]&
	u\otimes u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[d, "{(-,-)}\otimes u"]\ar[ur, bend right=5pt, start anchor={east}, end anchor={south west}, "u\otimes{(-,-)}"']\\
	u\otimes(p_1\tri p_2\tri(u\otimes p_3\tri q))\ar[r, "\varphi_{p_1\tri p_2}"']&
	u\otimes u\otimes p_1\tri p_2\tri p_3\tri q\ar[r, "{(-,-)}"]&
	u\otimes p_1\tri p_2\tri p_3\tri q
\end{tikzcd}
\]
The top-left and bottom-left squares commute by functoriality of monoidal products, and the bottom right square commutes by associativity of the $\otimes$-monoid structure on $u$. The rest is \cref{lemma.key}: the little triangle commutes by the statement $\varphi_{p\tri p'}=\varphi_{p}\circ (p\tri\varphi_{p'})$ and the pentagon commutes by the pentagon shown there.
\end{proof}

%-------- Chapter --------%
\chapter{Consequences in the language of dependent types}

The main theorem really just packages the story. The real heart of the matter---at least for dependent types---are what we call the key results. These are \cref{lemma.key} and its corollary, \cref{cor.key}, applied to $u$ across the board, where $u$ is a universe monad as in \cref{def.universe}. So fix a universe monad $(u,\1,\Sigma)$ for the rest of this section.

%---- Section ----%
\section{Notation}

Let $\U\coloneqq u(1)$. We denote each element of $\U$ using an upper-case letter, $A,B$, etc., and call it a \emph{base type}, or simply a \emph{type}. Given a base type $A\in u(1)$, we denote $u[A]$ simply by $[A]$, since $u$ is fixed. We denote each element of $[A]$ using the same letter in lower-case, $a,a':[A]$, etc., and call it a \emph{term of type $A$}. 

An element of $u\tri\U=u\tri u(1)=(u\tri u)(1)$ consists of an element $A\in\U$, and an element $B\, a\in\U$ for every $a\in [A]$. We denote it by $(A\vdash B)\in u\tri \U$ and call it a \emph{once-dependent type};. Similarly we can have $(n+1)$-fold dependent types
\[(A_1\vdash\cdots\vdash A_n\vdash B)\in u\tripow{n}\tri\U.\]
An element in $u\tripow{n}\tri u[A_1\vdash\cdots\vdash A_n\vdash B]$ consists of a term $a_1:A_1$, \dots, a term $a_n:A_n\, a_1\,\ldots\, a_n$, and a term $b\, a_1\,\ldots\, a_n:B\, a_1\,\ldots\, a_n$.

An element of $(u\otimes u)(1)$ consists of a pair $(A,B)\in\U\times\U$; we call it a \emph{product type}. An element of $(u\otimes u)[(A,B)]$ consists of a pair $(a,b)\in [A]\times[B]$. There is exactly one element of $\yon(1)$; we denote it $\1$. The set $\yon[\1]$ has a unique element, and we denote it $()$.

The cartesian monoid structures $(u,\1,\Sigma)$ and $(u,\1,(-,-))$, and the map $\indep\colon u\otimes u\to u\tri u$, are denoted as follows. The map $\1\colon\yon\to u$ provides a certain type, which we again call $\1\in U$. Its cartesianness means that $\1$ has a single term, which we again call $():[\1]$.

The map $\Sigma\colon u\tri u\to u$ provides a function $u\tri\U\to\U$, which we again call $\Sigma$. Thus for any dependent type $A\vdash B:u\tri\U$, we can form $\Sigma(A,B):\U$. Similarly the map $(-,-)\colon u\otimes u\to u$ provides a function $\U\times \U\to\U$, which we again denote $(-,-)$. Thus for any pair of types $(A,B):\U\times \U$ we can form $(A,B):\U$. The cartesianness of $\Sigma$ means that a term of $\Sigma(A,B)$ consists of an element of $u\tri u[(A\vdash B)]$, i.e.\ a term $a:[A]$ and a term $b:[Ba]$. Similarly, a term of $(A,B)$ consists of an element $(a,b):[A]\times[B]$. 

Note that only the notation is being created here; the rest just emerges from the meaning of $\tri$ and $\otimes$. If we leave some case out of our notation, e.g.\ how to denote an element of $u\tri(\U\otimes\U)$, one can simply make it up, as long as they understand how it corresponds to the relevant theory of polynomial functors.

The map $\varphi_{u,u}\colon u\tri (u\otimes u)\to u\otimes u\tri u$ from \cref{lemma.key} provides a function%
\footnote{As usual, $\tri$ binds the tightest, so $\U\times u\tri \U$ denotes $\U\times(u\tri \U)$.}
\begin{equation}\label{eqn.key_types}
	u\tri(\U\times\U)\to \U\times u\tri \U.
\end{equation}
For any dependent type $A\vdash B,C:u\tri(\U\times\U)$, we can form $A\to B,A\vdash C$, where $A\to B$ is an element of $\U$, and $A\vdash C$ is a dependent type. It is clear from the form of \eqref{eqn.key_types} that $C$ is not dependent on $A\to B$ here. Given a term $(b,a,c):(A\to B,A\vdash C)$, one can construct a term $(a,ba,c):u\tri(u\otimes u)[A\vdash B,C]$. Unlike the case for $\1$ and $\Sigma$, this construction is not a bijection because $\varphi_{u,u}$ is not cartesian, as explained in the footnote below \eqref{eqn.not_injective}.

It will be convenient to also have notation for the map from \eqref{eqn.corkey}, namely
\[\ol\varphi_{u,u,u}\colon (u\otimes u)\tri(u\otimes u)\to u\tri(u\otimes u\tri u).\]
Given a dependent type $(A,B)\vdash(C,D):(u\otimes u)\tri(\U\times \U)$, we can form a type which we denote 
\[A\vdash(B\to C,B\vdash D):u\tri(\U\otimes u\tri \U).\]
A term in it consists of $a:[A]$, $c:[B\to C]$, $b:[B]$, and $d:[Db]$. From any such term we can construct a term of the original type, namely
\[((a,ba),(c(ba), d(ba))):(u\otimes u)\tri(u\otimes u)[(A,B)\vdash(C,D)].\]

%---- Section ----%
\section{Unpacking the key results}


Before we start, note that we already have the pairing laws from the fact that $(-,-)$ and $\Sigma$ are cartesian monads.
\[
\begin{array}{cc}
	(A,\1)=A=(\1,A)&(A,(B,C))=((A,B),C)\\
	\Sigma(A,\1)=A=\Sigma(\1,A)&
		\Sigma(A,\Sigma(B,C))=\Sigma(\Sigma(A,B),C)
\end{array}
\]

We now unpack the equations from \cref{lemma.key,cor.key}, with $u$ in place of all $p$'s and $q$'s. Rather than read the equations off as is, we derive more human-readable, or expected results from them. We begin with commutative diagram \eqref{eqn.corkey_diag}
\[
\begin{tikzcd}[column sep=large]
	(u\otimes u)\tri(u\otimes u)\ar[r, "\ol\varphi_{u,u,u}"]\ar[d, "\varphi_{u\otimes u,u}"']&
	u\tri(u\otimes u\tri u)\ar[d, "\varphi_{u,u\tri u}"]\\
	u\otimes(u\otimes u)\tri u\ar[r, "u\otimes\indep"']&
	u\otimes u\tri u\tri u
\end{tikzcd}
\]
It says that for any dependent type $(A,B)\vdash(C,D)$, we can either form $((A,B)\to C),(A,B)\vdash D$ or $A\vdash (B\to C, B\vdash D)$; then applying $\indep$ to both sides we have
\[
((A,B)\to C)\vdash (A,B)\vdash D\equiv A\vdash (B\to C)\vdash B\vdash D
\]
There is an attendant conversion between terms: we can interchange $c,(a,b),d$ with $a,ca,b,d$. From here we can derive the rule $\Sigma(A\to C,A\to D)\equiv A\to\Sigma(C,D)$ by setting $B=\1$ and ...




%\[
%\begin{tabular}{p{3in}|p{2in}}
%	naturality with respect to $p\in\polycart$,\\applied to $\Sigma\colon u\tri u\to u$&
%		\\
%	naturality with respect to $\indep$&
%		\\
%	commutation with composition&
%		\\
%	the first diagram&
%		\\
%	the second diagram&
%		
%\end{tabular}
%\]










\printbibliography
\end{document}
